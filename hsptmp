#packopt name "Life Again"
#packopt icon "pictures/icon.ico"
#include "select_menu.as"
#include "hgimg3.as"
#include "modstr.as"
dmmini
randomize
cls 4
onexit gosub*owaru
;onerror goto*kyouseiowaru
title "Life again"
screen 0,1024,640,0,800,100//デバック 
redraw 0 : gwx=ginfo_winx : gwy=ginfo_winy

celload "pictures/stageback/001.png" : stagebackpic(0)=stat
celload "pictures/stageback/002.png" : stagebackpic(1)=stat
celload "pictures/stageback/003.png" : stagebackpic(2)=stat
celload "pictures/stageback/004.png" : stagebackpic(3)=stat

celload "pictures/cblockset.png" : mainpic(0)=stat
celload "pictures/blockset.png" : mainpic(1)=stat
celload "pictures/player_body3.png" : mainpic(2)=stat
celload "pictures/menu_death_back.png" : mainpic(3)=stat
celload "pictures/menu_death_yes.png" : mainpic(6)=stat
celload "pictures/menu_death_no.png" : mainpic(7)=stat
celload "pictures/clear_back.png" : mainpic(4)=stat
celload "pictures/oblockset.png" : mainpic(5)=stat
celload "pictures/enemy_set.png" : mainpic(8)=stat
celload "pictures/title_logo.png" : mainpic(9)=stat
celload "pictures/logo.png" : mainpic(10)=stat
celload "pictures/player_hp.png" : mainpic(11)=stat
celload "pictures/button_ue.png" : mainpic(12)=stat
celload "pictures/stage_selectUI.png" : mainpic(13)=stat
celload "pictures/small_soul_counter.png" : mainpic(14)=stat
celload "pictures/pose_menu0.png" : mainpic(15)=stat
celload "pictures/pose_menu1.png" : mainpic(16)=stat
celload "pictures/pose_menu2.png" : mainpic(17)=stat
celdiv mainpic(0),32,32 : celdiv mainpic(1),32,32
celdiv mainpic(2),64,64 : celdiv mainpic(5),32,32
celdiv mainpic(8),64,64

celload "pictures/maker/makeUI01.png" : makepic(0)=stat
celload "pictures/maker/makeUI02.png" : makepic(1)=stat
celload "pictures/maker/makeUI03.png" : makepic(2)=stat

celload "pictures/buttons/button00.png" : buttonpic(0)=stat
celload "pictures/buttons/button01.png" : buttonpic(1)=stat
celload "pictures/buttons/button02.png" : buttonpic(2)=stat
celload "pictures/buttons/button03.png" : buttonpic(3)=stat
celload "pictures/buttons/button04.png" : buttonpic(4)=stat
celload "pictures/buttons/button05.png" : buttonpic(5)=stat
celload "pictures/buttons/button06.png" : buttonpic(6)=stat

celload "pictures/魂.png" : effepic(0)=stat
celload "pictures/渦.png" : effepic(1)=stat
celload "pictures/stage_info.png" : effepic(2)=stat
celload "pictures/black_inout.png" : effepic(3)=stat
celload "pictures/big_soul0.png" : effepic(4)=stat
celload "pictures/damage_draw.png" : effepic(5)=stat
celdiv effepic(0),32,32 : celdiv effepic(1),64,64,32,32
celdiv effepic(2),320,128 : celdiv effepic(4),32,400
celdiv effepic(5),,,16,16

celload "pictures/story/player_bigbody.png" : storypic(0)=stat
celload "pictures/story/story_back00.png" : storypic(1)=stat
celload "pictures/story/telop.png" : storypic(2)=stat
celload "pictures/story/god.png" : storypic(3)=stat
celload "pictures/story/nexticon.png" : storypic(4)=stat
celload "pictures/story/house.png" : storypic(5)=stat
celload "pictures/story/player_bigbody.png" : storypic(6)=stat
celload "pictures/story/black_car.png" : storypic(7)=stat
celload "pictures/story/middleworld.png" : storypic(8)=stat
celload "pictures/story/god2.png" : storypic(9)=stat
celload "pictures/story/yes_button.png" : storypic(10)=stat
celload "pictures/story/no_button.png" : storypic(11)=stat
celdiv storypic(6),64,64

buffer 1000,gwx,gwy : tempic(0)=1000
gsel 0

dmmload "sounds/bgm_opening.wav",,1 : bgmsound(0)=stat
dmmload "sounds/bgm_select.wav",,1 : bgmsound(1)=stat
dmmload "sounds/bgm_maoudamashii_8bit20.wav",,1 : bgmsound(2)=stat
dmmload "sounds/bgm_mattarikibun.wav",,1 : bgmsound(3)=stat
dmmload "sounds/bgm_god.wav",,1 : bgmsound(4)=stat
dmmload "sounds/bgm_toikioku_healing.wav",,1 : bgmsound(5)=stat
dmmload "sounds/bgm_spring-mountain1.wav",,1 : bgmsound(6)=stat
dmmload "sounds/bgm_osare2.wav",,1 : bgmsound(7)=stat
dmmload "sounds/bgm_maoudamashii_8bit17.wav",,1 : bgmsound(8)=stat
dmmload "sounds/bgm_underground.wav",,1 : bgmsound(9)=stat
 
dmmload "sounds/maker/se_set_book.wav" : sesound(0)=stat
dmmload "sounds/maker/se_scratch.wav" : sesound(1)=stat
dmmload "sounds/se_death.wav" : sesound(2)=stat
dmmload "sounds/se_stageclear.wav" : sesound(3)=stat
dmmload "sounds/se_stageclear2.wav" : sesound(4)=stat
dmmload "sounds/se_smallsoul_get.wav" : sesound(5)=stat
dmmload "sounds/se_jump1.wav" : sesound(6)=stat
dmmload "sounds/se_jump2.wav" : sesound(7)=stat
dmmload "sounds/se_walk.wav" : sesound(8)=stat
dmmload "sounds/se_landing.wav" : sesound(9)=stat
dmmload "sounds/se_mapmove.wav" : sesound(10)=stat
dmmload "sounds/button01.wav" : sesound(11)=stat
dmmload "sounds/se_gutyo.wav" : sesound(12)=stat
dmmload "sounds/se_player_damage.wav" : sesound(13)=stat
dmmload "sounds/se_bone_crush.wav" : sesound(14)=stat
dmmload "sounds/se_enemy_rotation.wav" : sesound(15)=stat
dmmload "sounds/se_swimming.wav" : sesound(16)=stat
dmmload "sounds/se_japa-n.wav" : sesound(17)=stat
dmmload "sounds/se_door-open1.wav" : sesound(18)=stat
dmmload "sounds/se_walk-flooring1.wav" : sesound(19)=stat
dmmload "sounds/se_walk_big.wav" : sesound(20)=stat
dmmload "sounds/se_typing.wav" : sesound(21)=stat
dmmload "sounds/se_carbreke.wav" : sesound(22)=stat
dmmload "sounds/se_ga.wav" : sesound(23)=stat
dmmload "sounds/se_car_hit.wav" : sesound(24)=stat
dmmload "sounds/se_warp.wav" : sesound(25)=stat
dmmload "sounds/se_story_damage.wav" : sesound(26)=stat
dmmload "sounds/se_curebox.wav" : sesound(27)=stat
dmmload "sounds/se_boxopen.wav" : sesound(28)=stat
dmmload "sounds/se_glass_break.wav" : sesound(29)=stat

play_data_save_pace=50
play_data_load
first_dir=dir_cur
;first_story=1//デバック
goto*start_menu//デバック
;goto*var_set//デバック
;repeat : getkey a,32 : if a=1 : break
;await 16
;loop

*start_animation
	repeat 300
		redraw 1 : redraw 0
		color 0,0,0 : boxf
		if cnt<128 : color 243,0,255 : gmode 4,,,cnt*2 : pos 320,0 : celput mainpic(10),0,10,10
		if 128<=cnt : color 243,0,255 : gmode 4,,,512-cnt*2 : pos 320,0 : celput mainpic(10),0,10,10
		await 16
	loop
first_dir=dir_cur

*start_menu
	map_change=0 : fname="" : chdir first_dir
	dmmstop -1 : clrobj
	dmmplay bgmsound(8)
	smenufc 255,255,255//buttonの枠
	smreset : msmenu buttonpic(4),360,340 : msmenu buttonpic(5),360,500
	repeat
		redraw 1 : redraw 0
		gosub*keycontrol
		gmode 0 : pos 0,0 : celput mainpic(9)
		color 243,0,255 : gmode 4,,,255 : ssmenu 0,0,1 : a=stat
		;logmes "a="+a
		if a=0 & (enter=1 | lclick=1): break
		if a=1 & (enter=1 | lclick=1){
			//if first_story<=1 : dialog "最初のステージをクリアしてから作ることができます"
			//if first_story>1 : 
			break
		}
		if F1 : break
		if esc=1 : gosub *owaru
		await 16
		if cnt<64 : gmode 3,,,255-cnt*4 : pos 0,0 : celput effepic(3)//out
	loop
	dmmstop -1 : vs_nest=0
	repeat 64 : redraw 1 : redraw 0 : black_inout cnt,0 : await 16 : loop//演出
	if F1=1 : play_mode=1 : mload_mode=-1
	if a=0{//遊ぶ
		if first_story=0{
			wait 100
			story 0
			gosub *var_info : story 1
			story 2
			first_story=1 : a=0
		}
		play_mode=2 : mload_mode=3
	}
	if a=1 : play_mode=1 : mload_mode=0//作って遊ぶ

*var_set
	gosub*var_map : gosub*var_enemy : gosub*var_info : goto*play_select
	
*var_map
	;memo:block_numのブロックを消したら同じブロックをblockmnumからも消す
	 block_num=0,1,2,3,4,5,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23, 24,25,26,27,28,29,30,31,32,33,34//block_picture_number//プレイ用
	block_anip=1,1,1,1,1,3,1,1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1//block_picture_animation_per//アニメーションの必要なコマ数
	block_num_vol=length(block_num)
	a=0 : repeat block_num_vol : ccnt=cnt : repeat block_anip(ccnt) : block_str(a)="b("+a+")" : a++ : loop : loop//block_str
	
	block_mnum=0,1,2,3,5,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23, 24,25,26,27,28,29,30,31,32,33,34//block_picture_make_number//メーカー用(必要な奴だけ書いてって)
	repeat length(block_mnum) : block_mstr(cnt)="b("+block_mnum(cnt)+")" : loop : block_mnum_vol=length(block_mnum)
	
	cblock_num=0,47,94,141//connect_block_picture_num
	cblock_str="a(0)","a(1)","a(2)","a(3)" : cblock_num_vol=length(cblock_num)
	
	 oblock_num=0,8,32//other_block_picture_num
	oblock_anip=8,8, 8
	oblock_num_vol=length(oblock_num)
	a=0 : repeat oblock_num_vol : ccnt=cnt : repeat oblock_anip(ccnt) : oblock_str(a)="c("+a+")" : a++ : loop : loop//block_str
	
	
	;当たり判定のあるブロック（方向ごと）
	pbhl_str="a(0)","a(1)","a(2)","b(0)","b(1)","b(2)","b(8)","b(9)","b(10)","b(11)","b(12)","b(13)","b(14)","b(17)","b(19)","b(20)","b(21)","b(22)","b(23)","b(24)","b(25)","b(26)","b(27)","b(28)","b(29)","b(30)","b(31)","b(32)","b(33)","b(34)" : pbhl_str_vol=length(pbhl_str)//player_block_hit_left_str//左
	pbhu_str="a(0)","a(1)","a(2)","b(0)","b(1)","b(2)","b(8)","b(9)","b(10)","b(11)","b(12)","b(13)","b(14)","b(18)","b(19)","b(20)","b(21)","b(22)","b(23)","b(24)","b(25)","b(26)","b(27)","b(28)","b(29)","b(30)","b(31)","b(32)","b(33)","b(34)" : pbhu_str_vol=length(pbhu_str)//上
	pbhr_str="a(0)","a(1)","a(2)","b(0)","b(1)","b(2)","b(8)","b(9)","b(10)","b(11)","b(12)","b(13)","b(14)","b(15)","b(19)","b(20)","b(21)","b(22)","b(23)","b(24)","b(25)","b(26)","b(27)","b(28)","b(29)","b(30)","b(31)","b(32)","b(33)","b(34)" : pbhr_str_vol=length(pbhr_str)//右
	pbhd_str="a(0)","a(1)","a(2)","b(0)","b(1)","b(2)","b(8)","b(9)","b(10)","b(11)","b(12)","b(13)","b(14)","b(16)","b(19)","b(20)","b(21)","b(22)","b(23)","b(24)","b(25)","b(26)","b(27)","b(28)","b(29)","b(30)","b(31)","b(32)","b(33)","b(34)" : pbhd_str_vol=length(pbhd_str)//下
return

*var_enemy
	 enemy_num=0,6,12,18
	enemy_anip=6,6, 6, 6
	enemy_num_vol=length(enemy_num)
	a=0 : repeat enemy_num_vol : ccnt=cnt : repeat enemy_anip(ccnt) : enemy_str(a)="e("+a+")" : a++ : loop : loop//block_str

	 enemy_mnum=0,6,12,18//makerに表示する敵
	enemy_mnum_vol=length(enemy_num)
	eymovem=10
return

*var_info
	;mload_mode=-1//-1:何も読み込まない//0;newを読み込む//1:play_mode=2のとき//2:好きなステージを選んで読み込む//3:temp読み込み//4:fnameを代入してから読み込み//デバック
	;play_mode=1//0:遊ぶ//1:作る//2:ストーリーで遊ぶ//デバック
	black_mode=1//ブラックイン、アウトをする
	stage_map=0//選択ステージ
	px=0 : py=0//初期座標
	mx=32 : my=20 : drawmx=32 : drawmy=20//マップサイズ（マス）
	bsize=32//ブロックのサイズ
	mapvmv=1//map_void_mass_vol
	cblock_vol=47//connect_block_vol
	pxmovem=4 : pymovem=15//player_movex_max//プレイヤーの最大速度(ピクセル分)
	pxmovep=2 : pymovep=1//加速、減速のしやすさ
	pymovem_plus=5//下向きの重力パネルに重なったときにpymoveの最大値を変化させる
	player_hp=20 : player_hpm=20
	ptrans=255.0//プレイヤーの薄さ
	wx_move_flame=50 : wy_move_flame=50//wx_moveがrwx_moveの値になるのに何フレームいるか
	panicp=8//player_animation_check_per//一個のアニメーションを変えるまでのフレーム数
	panipc=4,4,2,4,2,4,1,1,4,4//player_ani_per_count//各アニメーションに使うコマの枚数(終点もしっかり書きましょう、配列が足りなくなります)
	a=0 : repeat length(panipc) : panip(cnt)=a : a=a+panipc(cnt) : loop//player_ani_per(終点もしっかり書きましょう、配列が足りなくなります)
	panipf=8,8,8,4,8,4,1,1,0//pani_per_flame//切り替えにかかるフレーム数
	sb_mode=0 : sblock="a(0)"//set_block_mode//0:ブロック//1:その他//2:敵
	play_data_save_pace=50//セーブするファイルの間隔
	pbh_cless=3//pbhのチェック回数を減らす
	kodama_vol=0

	mxmax=200 : mymax=100//x,yの最大マス数
	sdim map,0,mxmax+mapvmv*2,mymax+mapvmv*2//ブロックデータを保存する変数
	dim animap,mxmax+mapvmv*2,mymax+mapvmv*2//ブロックのアニメーション情報
	dim animapc,mxmax+mapvmv*2,mymax+mapvmv*2//ブロックのアニメーション情報
	sdim omap,0,mxmax+mapvmv*2,mymax+mapvmv*2//その他ブロック
	sdim emap,0,mxmax+mapvmv*2,mymax+mapvmv*2//敵
	dim edmap,mxmax+mapvmv*2,mymax+mapvmv*2//敵の方向
	dim ecmxmap,mxmax+mapvmv*2,mymax+mapvmv*2//敵の行動可能範囲(x)
	dim ecmymap,mxmax+mapvmv*2,mymax+mapvmv*2//敵の行動可能範囲(y)
	repeat mymax+mapvmv*2 : ycnt=cnt : repeat mxmax+mapvmv*2 : xcnt=cnt : map(xcnt,ycnt)="0" : animap(xcnt,ycnt)=0 : animapc(xcnt,ycnt)=0 : omap(xcnt,ycnt)="0" : emap(xcnt,ycnt)="0" : edmap(xcnt,ycnt)=0 : ecmxmap(xcnt,ycnt)=0 : ecmymap(xcnt,ycnt)=0  : loop : loop//マップを初期化

	;if mload_mode=0 : gosub*map_load
	if play_mode=1 : mload_mode=4 : fname="map/new" : ffname=fname : gosub *map_load : msave_mode=0//debug
return

*play_select
	clrobj//オブジェクト消去
	gosub *map_bgm
	if play_mode=0{
		goto*main
	}
	if play_mode=1{
		goto*mmain
	}
	if play_mode=2{
		goto*stage_select_main
	}
	title "いぇあ。ストップしたお(*play_selectの後)" : stop

*main//make
	back_to_select=0
	player_hp=player_hpm//体力リセット
	vs_nest=0 : pgoal=0 : pdeath=0 : pymove=0 : pg=0 : pxmove=0
	rwx_move=gwx/2-px : rwy_move=gwy/2-py//カメラの初期座標
	damage_effect_vol=0 : player_damage_mode=0 : pdcnt=0
	repeat
		//title ""+cnt
		redraw 1 : redraw 0
		acnt=cnt
		gosub*var_update
		gosub*keycontrol
		gosub*map_draw
		gosub*enemy_draw
		gosub*pdeath_check
		gosub*player_mode
		gosub*player_draw
		gosub*player_UI
		if esc=1 : gosub*pose_menu
		if black_mode=1 &  cnt<64 : black_inout cnt,1
		/*プレイヤーの描画は「１：描画　２：座標移動」のため描画自体は前回の座標になっている。なので、これ以降に
		プレイヤー座標関係の処理を行うと、１フレーム前の処理になってしまうためやめたほうがいい*/
		if vs_nest=1 : break
		await 16
	loop
	if back_to_select=1{
		if map_change=1 : dialog "マップを保存しますか？",2 : a=stat : if a=6 : msave_mode=0 : gosub*map_save
		black_inout 0,2 : goto*start_menu
	}
	if back_to_select=2 : black_inout 0,2 : wait 10 : goto*stage_select_main
	if pgoal=1 : goto*stage_clear//ゴール時の演出
	if pdeath=1 : goto*menu_death//死亡時の演出
	if F1=1 & play_mode=0 : px=fpx : py=fpy : mload_mode=3 : gosub*map_load : black_mode=0 : goto*main//同じステージを再度読み込み//違うステージを読み込み
	if F3=1 & play_mode=0 : play_mode=1 : mload_mode=3 : gosub*map_load : wx_move=gwx/2-px : wy_move=gwy/2-py : goto*play_select//作るモードに切り替え
	
*mmain//make_main
	vs_nest=0 : menu=0 : pg=0 : back_to_select=0
	smreset//ボタン初期化
	smenufc 0,0,0//buttonの枠
	msmenu buttonpic(1),890,480 : msmenu buttonpic(0),890,530 : msmenu buttonpic(6),890,580 : msmenu buttonpic(2),730,555 : msmenu buttonpic(3),730,590
	clrobj
	pos 0,0 : input iranaiinput,0,0 : pos 730,497 : input mx,40,20,3 : pos 730,535 : input my,40,20,3//マップのサイズ変更よう
	pos 800,480 : chkbox "塗りつぶし",fill_mode
	repeat
		redraw 1 : redraw 0
		acnt=cnt
		gosub*var_update
		gosub*keycontrol
		gosub*map_draw
		gosub*player_mode
		gosub*mplayer_draw//make_player_draw
		gosub*makeUI
		gosub*anything_set
		if esc=1 : gosub*pose_menu
		await 16
		if black_mode=1 & cnt<64 : black_inout cnt,1
		if vs_nest=1 : break
	loop
	;key
	if F3=1 & play_mode=1{
		check=msave_mode : msave_mode=2 : gosub*map_save : msave_mode=check
		if goalcheck=0 : play_mode=1 : goto*play_select
		if goalcheck=1 : play_mode=0 : mload_mode=3 : gosub*map_load : goto*play_select//いったんマップをtempに保存して遊ぶモードにする
	}
	;button
	if back_to_select=1{
		if map_change=1 : dialog "マップを保存しますか？",2 : a=stat : if a=6 : msave_mode=0 : gosub*map_save
		black_inout 0,2 : goto*start_menu
	}
	if menu=1 | F1=1{//読み込み
		mload_mode=2 : gosub*map_load : msave_mode=1 :  wx_move=gwx/2-px : wy_move=gwy/2-py
		if black_mode=1 : repeat 64 : redraw 1 : redraw 0 : black_inout cnt,0 : await 16 : loop
		goto*mmain
	}
	if menu=2 | (menu=3 & msave_mode=0){
		check=msave_mode//もし保存できなかったら、元に戻す
		msave_mode=0 : gosub*map_save : msave_mode=1 : black_mode=0 : goto*mmain//名前を付けて保存
	}
	if menu=3 : msave_mode=1 : gosub*map_save : black_mode=0 : goto*mmain//上書き保存
	if menu=4{//まっさらにする
		gosub*clean_map
		mx=32 : my=20 : px=bsize*5 : py=msy-bsize*4 : fpx=0 : fpy=0 : wx_move=200 : wy_move=gwy/2-py : black_mode=0
		goto*mmain
	}
*stage_select_main
	pdeath=0 : pgoal=0 : pg=0 : pymove=0 : pxmove=0 : back_to_select=0 : player_hp=player_hpm
	gosub *stage_select_load//ステージのマップをロード
	if map_move=1 : px=smpx : py=smpy : wx_move=gwx/2-px : wy_move=gwy/2-py : rwx_move=gwx/2-px : rwy_move=gwy/2-py
	rsgate//ゲートをリセット
	dmmstop -1
	if stage=0{//ゲートを配置
		dmmplay bgm_sound(0)//bgm
		mkgate "チュートリアル",580,320
		mkgate "www初めの草原www",1088,380
		mkgate "深く洞窟へ",1248,940
		mkgate "氷が溶けだした山",2272,352
	}stage_map_name=""
	vs_nest=0 : map_move=0
	repeat
		redraw 1 : redraw 0
		acnt=cnt
		gosub*var_update
		gosub*keycontrol
		gosub*map_draw : drgate
		gosub*pdeath_check
		gosub*player_mode
		gosub*player_draw
		color 243,0,255 : gmode 4,,,255 : pos 0,0 : celput mainpic(13) : font "",32 : color 0,0,0 : pos 292,0 : mes akodama_vol
		if esc=1 : logmes "通った" : gosub*pose_menu
		if cnt<64 : black_inout cnt,1
		await 16
		if vs_nest=1 : break
	loop
	logmes "通った2" : 
	if back_to_select=1 : black_inout 0,2 : wait 10 : goto*start_menu
	if ue=1 & map_move=1 : mload_mode=1 : smpx=px : smpy=py : goto*map_move_animation//select_main_px
*stage_select_load
	mload_mode=4 : gosub*clean_map : fname="map/stage_select/"+stage : gosub*map_load//ステージ選択用のマップを読み込み
return

*map_move_animation
	b=200 : mmani=1//map_move_animation
	ga=0//元いたウィンド
	bai=1.5
	repeat b
		redraw 1 : redraw 0
		gosub*keycontrol
		gosub*map_draw
		drgate
		
		color 243,0,255 : gmode 4,,,255 : //プレイヤーを描画
		if pg=0 | pg=4 :  pos px+wx_move,py+wy_move : celput mainpic(2),pani
		if pg=2 : pos px+wx_move+psizex,py+wy_move : celput mainpic(2),pani,,,deg2rad(180)

		gsel tempic(0)
		gmode 0 : pos 0,0 : celput ga
		gsel ga// : celdiv tempic(0),,,px+wx_move+psizex,py+wy_move+psizey/2
		color 0,0,0 : boxf
		//pos 0,0 : gzoom gwx,gwy,tempic(0),(px+wx_move+psizex-cnt),(py+wy_move+psizey/2-cnt),3.2*cnt,2.0*cnt
		pos 0,0 : gzoom gwx,gwy,tempic(0),cnt*bai+psizex,cnt*bai,gwx-3.2*cnt*bai,gwy-2.0*cnt*bai
		//logmes "x="+(px+wx_move+psizex-cnt)+" y="+(py+wy_move+psizey/2-cnt)+"x="+(3.2*cnt)+" y="+(2.0*cnt)
		//pos px+wx_move+psizex,py+wy_move+psizey/2 : celput tempic(0),,0.5*cnt+1,0.4*cnt+1
		//celdiv tempic(0),,0,0
		if cnt>b-64 : black_inout cnt,0
		await 16
	loop
	mmani=0
	gosub*clean_map : mload_mode=1 : gosub*map_load : gosub *map_bgm : goto*main

*var_update
	msx=bsize*mx : msy=bsize*my
	if mx<0 | mxmax<mx : mx=limit(mx,0,mxmax) : objprm 0,mx
	if my<0 | mymax<my : my=limit(my,0,mymax) : objprm 0,my
	//mx=limit(mx,0,mxmax) : my=limit(my,0,mymax)
	//objprm 0,mx : objprm 1,my
return
*keycontrol
	getkey lclick,1 : getkey rclick,2 : getkey mclick,4
	getkey enter,13 : getkey shift,16 : getkey ctrl,17 : getkey space,32
	getkey hidari,37 : getkey ue,38 : getkey migi,39 : getkey sita,40
	
	getkey esc,27 : getkey F1,112 : getkey F2,113 : getkey F3,114
	if F1=1 & play_mode=0 : vs_nest=1
	;if F2=1 & play_mode=1 : vs_nest=1
	if F3=1 & F3p=0 & (play_mode=0 | play_mode=1) : F3p=1 : vs_nest=1 : else : if F3=0 : F3p=0

	moux=mousex : mouy=mousey : mouw=mousew//マウスの値
	;if lclick=1 : logmes "mousex="+(mousex-wx_move)+" mousey="+(mousey-wy_move)
return

*map_bgm
	dmmstop -1
	if play_mode=0 : dmmplay bgmsound(0)
	if play_mode=1 : dmmplay bgmsound(7)
	if play_mode=2{
		a=stage_map_name
		;logmes "ステージ名は"+a
		if stage=0{
			if a="" | a="www初めの草原www" | a="氷が溶けだした山" : dmmplay bgmsound(0)
			if a="チュートリアル" : dmmplay bgmsound(5)
			if a="深く洞窟へ" : dmmplay bgmsound(9)
		}
	}
return
*map_back
	pos wx_move/10,wy_move/10
	if play_mode=0 | play_mode=1 : celput stagebackpic(0)//春みたいな
	if play_mode=2{
		a=stage_map_name
		;logmes "ステージ名は"+a
		if stage=0{
			if a="" | a="www初めの草原www" : celput stagebackpic(0)
			if a="チュートリアル" : celput stagebackpic(1)//方眼紙
			if a="深く洞窟へ" : celput stagebackpic(2)//洞窟
			if a="氷が溶けだした山" : celput stagebackpic(3)//空
		}
	}
	
return
*map_draw//マップを描画
	;wx,wy_move制御(プレイヤー移動時)
	
	if play_mode=0 | play_mode=2{//遊んでいたら
		rwx_move=gwx/2-px : rwy_move=gwy/2-py//実際のカメラ位置
		wx_movec=(rwx_move-wx_move)/wx_move_flame : wy_movec=(rwy_move-wy_move)/wy_move_flame*2//移動する幅
		wx_move=limit(wx_move+wx_movec,-abs(gwx-msx),0) : wy_move=limit(wy_move+wy_movec,-abs(gwy-msy),0)//カメラの位置決定
		;logmes "wx_move="+wx_move+" wy_move="+wy_move+" rwx_move="+rwx_move+" rwy_move="+rwy_move
	}
		
	;back//背景
	if mclick=1 & (play_mode=0 | play_mode=1){//ホイールクリックで画面を移動
		if mclickp=0 : bmoux=moux : bmouy=mouy : bwx_move=wx_move : bwy_move=wy_move : mclickp=1//マウスホイールを押したら今のmoux,mouy,wx_move,wy_moveの値を一時保存
		if mclickp=1 : wx_move=bwx_move-(bmoux-moux) : wy_move=bwy_move-(bmouy-mouy)
		if play_mode=0 : wx_move=limit(wx_move+wx_movec,-abs(gwx-msx),0) : wy_move=limit(wy_move+wy_movec,-abs(gwy-msy),0)
	}if mclick=0 & mclickp=1 : mclickp=0
	if mmani=0 : gmode 0 : color 0,0,0 : boxf
	gosub*map_back
	
	//color 250,250,250 : boxf//加工用
	
	;線
	if play_mode=1{
		color 0,0,0
		repeat mx : line bsize*cnt+wx_move,0,bsize*cnt+wx_move,gwy : loop
		repeat my : line 0,bsize*cnt+wy_move,gwx,bsize*cnt+wy_move : loop
		color 255,0,0 : boxline wx_move,wy_move,wx_move+msx,wy_move+msy//line wx_move,0,wx_move,gwy : line wx_move+msx,0,wx_move+msx,gwy
	}
	;block//ブロック
	repeat drawmy+2//my
		ycnt=cnt+mapvmv-wy_move/bsize
		repeat drawmx+2//mx
			xcnt=cnt+mapvmv-wx_move/bsize : check=0
			//logmes "xcnt="+xcnt+" ycnt="+ycnt
			//if -bsize<bsize*(xcnt-mapvmv)+wx_move & bsize*(xcnt-mapvmv)+wx_move<gwx & -bsize<bsize*(ycnt-mapvmv)+wy_move & bsize*(ycnt-mapvmv)+wy_move<gwy{
			if 0<xcnt & xcnt<=mx & 0<ycnt & ycnt<=my{
				;その他ブロック
				check=0
				c=omap(xcnt,ycnt)//確認用
				d=strmid(c,0,1)//一時的
				gmode 3,,,150
				if d="c"{//その他のブロック配置
					pos bsize*(xcnt-mapvmv)+wx_move,bsize*(ycnt-mapvmv)+wy_move//貼る位置
					repeat//カッコの中の数を代入する
						ccnt=cnt
						a=strmid(c,2+ccnt,1)//a:一時的
						if a=")" : break
					loop
					b=int(strmid(c,2,ccnt))//b:一時的に()の中の数字を代入
					hosii=oblock_num(b)

					min=0 : max=oblock_num_vol-1 : ans=(max-min)/2
					repeat;二分探索法でbと該当するblock_numの番号を求める
						if oblock_num(ans)>hosii : max=ans : ans=ans-(max-min)/2
						if oblock_num(ans)<hosii : min=ans : ans=ans+(max-min)/2
						if min=hosii & max=1 : ans=0
						if min=oblock_num_vol-2 : max=oblock_num_vol-1 : ans=oblock_num_vol-1
						//logmes "ほしい値は"+hosii+" oblock_num(ans)="+oblock_num(ans)+" ans="+ans+" min="+min+" max="+max
						if oblock_num(ans)=hosii : break
						//await 1
					loop
					//logmes "break!!"
					if oblock_anip(ans)=1 : celput mainpic(5), oblock_num(ans) : check=1
					if oblock_anip(ans)!1 : celput mainpic(5), oblock_num(ans)+animap(xcnt,ycnt) : check=1
					;アニメーションを更新
					if play_mode=0 | play_mode=2{
						if c="c(0)" | c="c(1)" : animapc(xcnt,ycnt)++ : if animapc(xcnt,ycnt)\10=0 : animap(xcnt,ycnt)++ : animap(xcnt,ycnt)=animap(xcnt,ycnt)\oblock_anip(ans) : animapc(xcnt,ycnt)=0
						if c="c(2)" : animapc(xcnt,ycnt)++ : if animapc(xcnt,ycnt)\5=0 : animap(xcnt,ycnt)++ : animap(xcnt,ycnt)=animap(xcnt,ycnt)\oblock_anip(ans) : animapc(xcnt,ycnt)=0
					}
				}
				;通常ブロック
				check=0
				pos bsize*(xcnt-mapvmv)+wx_move,bsize*(ycnt-mapvmv)+wy_move//貼る位置
				c=map(xcnt,ycnt)//確認用
				d=strmid(c,0,1)//一時的
				color 243,0,255 : gmode 4,,,255
				
				if d="a"{//connectブロックを配置
					repeat//カッコの中の数を代入する
						ccnt=cnt
						a=strmid(c,2+ccnt,1)//a:一時的
						if a=")" : break
					loop
					b=strmid(c,2,ccnt)//b:一時的に()の中の数字を代入
					color 243,0,255 : gmode 4,,,255
					
					if map(xcnt-1,ycnt)=c & map(xcnt,ycnt-1)=c & map(xcnt+1,ycnt)=c & map(xcnt,ycnt+1)=c & check=0{;４個//全包囲されてる
						if map(xcnt-1,ycnt+1)!c & map(xcnt-1,ycnt-1)!c & map(xcnt+1,ycnt-1)!c & map(xcnt+1,ycnt+1)!c & check=0 : celput mainpic(0),30+cblock_vol*b : check=1;4箇所空白
						if map(xcnt-1,ycnt+1)!c & map(xcnt-1,ycnt-1)!c & map(xcnt+1,ycnt-1)!c & check=0 : celput mainpic(0),26+cblock_vol*b : check=1;3箇所空白//左下と左上と右上
						if map(xcnt-1,ycnt-1)!c & map(xcnt+1,ycnt-1)!c & map(xcnt+1,ycnt+1)!c & check=0 : celput mainpic(0),27+cblock_vol*b : check=1//左上と右上と右下
						if map(xcnt+1,ycnt-1)!c & map(xcnt+1,ycnt+1)!c & map(xcnt-1,ycnt+1)!c & check=0 : celput mainpic(0),28+cblock_vol*b : check=1//右上と右下と左下
						if map(xcnt+1,ycnt+1)!c & map(xcnt-1,ycnt+1)!c & map(xcnt-1,ycnt-1)!c & check=0 : celput mainpic(0),29+cblock_vol*b : check=1//右下と左下と左上
						if map(xcnt-1,ycnt+1)!c & map(xcnt-1,ycnt-1)!c & check=0 : celput mainpic(0),20+cblock_vol*b : check=1;2箇所空白//左下と左上
						if map(xcnt-1,ycnt-1)!c & map(xcnt+1,ycnt-1)!c & check=0 : celput mainpic(0),21+cblock_vol*b : check=1//左上と右上
						if map(xcnt+1,ycnt-1)!c & map(xcnt+1,ycnt+1)!c & check=0 : celput mainpic(0),22+cblock_vol*b : check=1//右上と右下
						if map(xcnt+1,ycnt+1)!c & map(xcnt-1,ycnt+1)!c & check=0 : celput mainpic(0),23+cblock_vol*b : check=1//右下と左下
						if map(xcnt-1,ycnt-1)!c & map(xcnt+1,ycnt+1)!c & check=0 : celput mainpic(0),24+cblock_vol*b : check=1//左上と右下
						if map(xcnt-1,ycnt+1)!c & map(xcnt+1,ycnt-1)!c & check=0 : celput mainpic(0),25+cblock_vol*b : check=1//左下と右上
						if map(xcnt-1,ycnt-1)!c & check=0 : celput mainpic(0),16+cblock_vol*b : check=1//左上
						if map(xcnt+1,ycnt-1)!c & check=0 : celput mainpic(0),17+cblock_vol*b : check=1//右上
						if map(xcnt+1,ycnt+1)!c & check=0 : celput mainpic(0),18+cblock_vol*b : check=1//右下
						if map(xcnt-1,ycnt+1)!c & check=0 : celput mainpic(0),19+cblock_vol*b : check=1//左下
						if check=0 : celput mainpic(0),15+cblock_vol*b : check=1//端が埋まってる
					}
					if map(xcnt,ycnt-1)=c & map(xcnt+1,ycnt)=c & map(xcnt,ycnt+1)=c & check=0{;３個囲まれてる〜//左向き
						if map(xcnt+1,ycnt-1)!c & map(xcnt+1,ycnt+1)!c & check=0 : celput mainpic(0),39+cblock_vol*b : check=1//右上と右下
						if map(xcnt+1,ycnt-1)!c & check=0 : celput mainpic(0),38+cblock_vol*b : check=1//右上
						if map(xcnt+1,ycnt+1)!c & check=0 : celput mainpic(0),37+cblock_vol*b : check=1//右下
						if check=0 : celput mainpic(0),11+cblock_vol*b : check=1
					}if map(xcnt-1,ycnt)=c & map(xcnt+1,ycnt)=c & map(xcnt,ycnt+1)=c & check=0{//上向き
						if map(xcnt+1,ycnt+1)!c & map(xcnt-1,ycnt+1)!c & check=0 : celput mainpic(0),42+cblock_vol*b : check=1//右下と左下
						if map(xcnt+1,ycnt+1)!c & check=0 : celput mainpic(0),41+cblock_vol*b : check=1//右下
						if map(xcnt-1,ycnt+1)!c & check=0 : celput mainpic(0),40+cblock_vol*b : check=1//左下
						if check=0 : celput mainpic(0),12+cblock_vol*b : check=1
					}if map(xcnt-1,ycnt)=c & map(xcnt,ycnt-1)=c & map(xcnt,ycnt+1)=c & check=0{//右向き
						if map(xcnt-1,ycnt+1)!c & map(xcnt-1,ycnt-1)!c & check=0 : celput mainpic(0),33+cblock_vol*b : check=1;2箇所空白//左下と左上
						if map(xcnt-1,ycnt-1)!c & check=0 : celput mainpic(0),31+cblock_vol*b : check=1//左上
						if map(xcnt-1,ycnt+1)!c & check=0 : celput mainpic(0),32+cblock_vol*b : check=1//左下
						if check=0 : celput mainpic(0),13+cblock_vol*b : check=1
					}if map(xcnt-1,ycnt)=c & map(xcnt,ycnt-1)=c & map(xcnt+1,ycnt)=c & check=0{//下向き
						if map(xcnt-1,ycnt-1)!c & map(xcnt+1,ycnt-1)!c & check=0 : celput mainpic(0),36+cblock_vol*b : check=1//左上と右上
						if map(xcnt-1,ycnt-1)!c & check=0 : celput mainpic(0),35+cblock_vol*b : check=1//左上
						if map(xcnt+1,ycnt-1)!c & check=0 : celput mainpic(0),34+cblock_vol*b : check=1//右上
						if check=0 : celput mainpic(0),14+cblock_vol*b : check=1
					}
					if map(xcnt-1,ycnt)=c & map(xcnt+1,ycnt)=c & check=0 : celput mainpic(0),9+cblock_vol*b : check=1;２個囲まれてる〜//横に２つある
					if map(xcnt,ycnt-1)=c & map(xcnt,ycnt+1)=c & check=0 : celput mainpic(0),10+cblock_vol*b : check=1//縦に２つある
					if map(xcnt+1,ycnt)=c & map(xcnt,ycnt+1)=c & check=0{//右と下にある
						if map(xcnt+1,ycnt+1)!c & check=0 : celput mainpic(0),45+cblock_vol*b : check=1
						if check=0 : celput mainpic(0),5+cblock_vol*b : check=1
					}if map(xcnt-1,ycnt)=c & map(xcnt,ycnt+1)=c & check=0{//左と下にある
						if map(xcnt-1,ycnt+1)!c & check=0 : celput mainpic(0),46+cblock_vol*b : check=1
						if check=0 : celput mainpic(0),6+cblock_vol*b : check=1
					}if map(xcnt-1,ycnt)=c & map(xcnt,ycnt-1)=c & check=0{//左と上にある
						if map(xcnt-1,ycnt-1)!c & check=0 : celput mainpic(0),43+cblock_vol*b : check=1
						if check=0 : celput mainpic(0),7+cblock_vol*b : check=1
					}if map(xcnt+1,ycnt)=c & map(xcnt,ycnt-1)=c & check=0{//右と上にある
						if map(xcnt+1,ycnt-1)!c & check=0 : celput mainpic(0),44+cblock_vol*b : check=1
						if check=0 : celput mainpic(0),8+cblock_vol*b : check=1
					}
					if map(xcnt+1,ycnt)=c & check=0 : celput mainpic(0),1+cblock_vol*b : check=1;１個囲まれてる//右にある
					if map(xcnt-1,ycnt)=c & check=0 : celput mainpic(0),2+cblock_vol*b : check=1//左にある
					if map(xcnt,ycnt+1)=c & check=0 : celput mainpic(0),3+cblock_vol*b : check=1//下にある
					if map(xcnt,ycnt-1)=c & check=0 : celput mainpic(0),4+cblock_vol*b : check=1//上にある
					if check=0 :  celput mainpic(0),0+cblock_vol*b : check=1
				}
				if d="b" & check=0{//普通のブロック配置
					repeat//カッコの中の数を代入する
						ccnt=cnt
						a=strmid(c,2+ccnt,1)//a:一時的
						if a=")" : break
					loop
					b=int(strmid(c,2,ccnt))//b:一時的に()の中の数字を代入

					min=0 : max=block_num_vol-1 : ans=(max-min)/2
					repeat;二分探索法でbと該当するblock_numの番号を求める
						if block_num(ans)>b : max=ans : ans=ans-(max-min)/2
						if block_num(ans)<b : min=ans : ans=ans+(max-min)/2
						if min=0 & max=1 : ans=0
						if min=block_num_vol-2 : max=block_num_vol-1 : ans=block_num_vol-1
						//logmes "ほしい値は"+b+" block_num(ans)="+block_num(ans)+" ans="+ans+" min="+min+" max="+max
						if block_num(ans)=b : break
						//await 1
					loop
					//logmes "break!!"
					
					if block_anip(ans)=1 : celput mainpic(1),b : check=1
					if block_anip(ans)!1 : celput mainpic(1),b+animap(xcnt,ycnt) : check=1
					;アニメーションを更新
					if (play_mode=0 | play_mode=2){
						if c="b(5)" : animapc(xcnt,ycnt)++ : if animapc(xcnt,ycnt)\20=0 : animap(xcnt,ycnt)++ : animap(xcnt,ycnt)=animap(xcnt,ycnt)\block_anip(ans) : animapc(xcnt,ycnt)=0//小魂
					}
				}
				;敵
				if play_mode=1{//作るモードの時
					c=emap(xcnt,ycnt)//確認用
					d=strmid(c,0,1)//一時的
					if d="e"{//敵を配置
						pos bsize*(xcnt-mapvmv)-bsize/2+wx_move,bsize*(ycnt-mapvmv)-bsize+wy_move//貼る位置
						repeat//カッコの中の数を代入する
							ccnt=cnt
							a=strmid(c,ccnt,1)//a:一時的
							if a=")" : break
						loop
						b=int(strmid(c,2,ccnt))//b:一時的に()の中の数字を代入
						hosii=enemy_num(b)
	
						min=0 : max=enemy_num_vol-1 : ans=(max-min)/2
						repeat;二分探索法でbと該当するblock_numの番号を求める
							if enemy_num(ans)>hosii : max=ans : ans=ans-(max-min)/2
							if enemy_num(ans)<hosii : min=ans : ans=ans+(max-min)/2
							if min=hosii & max=1 : ans=0
							if min=enemy_num_vol-2 : max=enemy_num_vol-1 : ans=enemy_num_vol-1
							;logmes "ほしい値は"+hosii+" oblock_num(ans)="+oblock_num(ans)+" ans="+ans+" min="+min+" max="+max
							if enemy_num(ans)=hosii : break
							;await 1
						loop
						//logmes "break!!"
						;logmes "c="+c
						if ans=0 | ans=1 | ans=2 | ans=3{
							;logmes "通った"
							celput mainpic(8),enemy_num(ans)+(enemy_anip(ans)/2)*(edmap(xcnt,ycnt)\2) : check=1//描画
						}
					}
				}
			//if pgoal=1 : logmes "xcnt="+xcnt+" ycnt="+ycnt
			}
		loop
	loop
return

*enemy_draw
	;logmes "enemy_vol="+enemy_vol
	canjump=0
	repeat enemy_vol
		ecnt=cnt
		a=enemysnum(ecnt)//敵の番号
		if -wx_move-bsize*5<=enemypx(ecnt) & enemypx(ecnt)<-wx_move+gwx+bsize*5 & -wy_move-bsize*5<=enemypy(ecnt) & enemypy(ecnt)<-wy_move+gwy+bsize*5 & enemyl(ecnt)!0{
			
*enemy_bedodo
			if a=0{//もしベドドなら〜
				enemy_info 25,35,38,63
				epos bsize/2,bsize : color 243,0,255
				if enemyl(ecnt)=0{//死んでたら
					if edcnt(ecnt)<8{//一定時間描画
						edcnt(ecnt)++
						if enemydir(ecnt)=0{//もし左向きだったら〜
							celput mainpic(8),enemy_num(a)+(enemy_anip(a)/2)-1
						}
						if enemydir(ecnt)=1{//もし右向きだったら〜
							celput mainpic(8),enemy_num(a)+enemy_anip(a)-1
						}
					}
				}
				if enemyl(ecnt)>0{//生きてたら
					if enemydir(ecnt)=0 & edcheck(ecnt)=0{//もし左向きだったら〜
						celput mainpic(8),enemy_num(a)+((enemy_anipc(ecnt)/20)\((enemy_anip(a)/2)-1))
						;左
						enemypx(ecnt)-0.5 : ebh 0,0,0,255,0 : d=stat; : logmes "d="+d
						//if d=0 : ブロックがなかったら移動させる
						if d!0 : enemydir(ecnt)=1 : enemy(ecnt)+0.5 : edcheck(ecnt)=1
					}
					if enemydir(ecnt)=1 & edcheck(ecnt)=0{//もし右向きだったら〜
						celput mainpic(8),enemy_num(a)+((enemy_anipc(ecnt)/20)\((enemy_anip(a)/2)-1))+enemy_anip(a)/2
						;右
						enemypx(ecnt)+0.5 : ebh 2,0,0,255,0 : d=stat; : logmes "d="+d
						//if d=0 : ブロックがなかったら移動させる
						if d!0 : enemydir(ecnt)=0 : enemy(ecnt)-0.5 : edcheck(ecnt)=1
					}
					ebh 3 : d=stat
					if d=0 : eymove(ecnt)+1//地面がなかったら
					;上下移動
					repeat abs(eymove(ecnt))
						if eymove(ecnt)<0{//上昇中だったら
							ebh 1,0,255,100,255 : d=stat
							if d=0 : enemypy(ecnt)-1
							if d!0 : eymove(ecnt)=0 : break
						}if eymove(ecnt)>0{//下降中だったら
							ebh 3,0,0,255,255 : d=stat
							if d=0 : enemypy(ecnt)+1
							if d!0 : eymove(ecnt)=0 : break
						}
					loop
					ehitcheck 3,0,1
					enemy_anipc(ecnt)++
					if enemyl(cnt)=0 : dmmplay sesound(12)//死亡音
				}
				
			}
*enemy_gaikotu
			if a=1 | a=2{//もし骸骨なら〜
				;logmes "通った"
				enemy_info 22,35,42,63
				epos bsize/2,bsize : color 243,0,255
				if enemyl(ecnt)=0{//死んでたら
					if edcnt(ecnt)<8{//一定時間描画
						edcnt(ecnt)++
						if enemydir(ecnt)=0{//もし左向きだったら〜
							celput mainpic(8),enemy_num(a)+(enemy_anip(a)/2)-1
						}
						if enemydir(ecnt)=1{//もし右向きだったら〜
							celput mainpic(8),enemy_num(a)+enemy_anip(a)-1
						}
					}
				}
				if enemyl(ecnt)>0{//生きてたら
					if enemydir(ecnt)=0 & edcheck(ecnt)=0{//もし左向きだったら〜
						celput mainpic(8),enemy_num(a)+((enemy_anipc(ecnt)/20)\((enemy_anip(a)/2)-1))
						ebh 0,0,0,255,0 : d=stat; : logmes "d="+d//左にブロックがあるか
						//if d=0 : ブロックがなかったら移動させる
						if d=0{
							if a=1 : exmove(ecnt)=-1.0
							if a=2 : exmove(ecnt)=-2.0
						}
						if ((enemy_anipc(ecnt)/20)\((enemy_anip(a)/2)-1))=0 : exmove(ecnt)=0.0//口を開いてないときは動かない
						
					}
					if enemydir(ecnt)=1 & edcheck(ecnt)=0{//もし右向きだったら〜
						celput mainpic(8),enemy_num(a)+((enemy_anipc(ecnt)/20)\((enemy_anip(a)/2)-1))+enemy_anip(a)/2
						ebh 2,0,0,255,0 : d=stat; : logmes "d="+d//右にブロックがあるか
						if d=0{
							if a=1 : exmove(ecnt)=1.0
							if a=2 : exmove(ecnt)=2.0
						}
						if ((enemy_anipc(ecnt)/20)\((enemy_anip(a)/2)-1))=0 : exmove(ecnt)=0.0//口を開いてないときは動かない
					}
					;左右移動
					repeat abs(exmove(ecnt))
						if exmove(ecnt)<0{//左へ移動している
							ebh 0,0,255,0,100 : d=stat; : logmes "d="+d
							if d=0 : enemypx(ecnt)-1
							if d!0 : enemydir(ecnt)=1 : edcheck(ecnt)=1 :  break//向きを変える
						}if exmove(ecnt)>0{//右へ移動している
							ebh 2,0,0,255,100 : d=stat; : logmes "d="+d
							if d=0 : enemypx(ecnt)+1
							if d!0 : enemydir(ecnt)=0 : edcheck(ecnt)=1 : break//向きを変える
						}
					loop
					;logmes "enemydir="+enemydir(ecnt)
					;logmes "終わり！"
					;上下移動
					ebh 3 : d=stat
					if d=0 : eymove(ecnt)+1//地面がなかったら
					if d!0{//地面があったら
						if enemy_check(ecnt)=0 & ((enemy_anipc(ecnt)/20)\((enemy_anip(a)/2)-1))=1 : eymove(ecnt)=-6//口を開いたらジャンプさせる
						enemy_check(ecnt)=((enemy_anipc(ecnt)/20)\((enemy_anip(a)/2)-1))
					}
					repeat abs(eymove(ecnt))
						if eymove(ecnt)<0{//上昇中だったら
							ebh 1,0,255,100,255 : d=stat
							if d=0 : enemypy(ecnt)-1
							if d!0 : eymove(ecnt)=0 : break
						}if eymove(ecnt)>0{//下降中だったら
							ebh 3,0,0,255,255 : d=stat
							if d=0 : enemypy(ecnt)+1
							if d!0 : eymove(ecnt)=0 : break
						}
					loop
					if a=1 : ehitcheck 5,0,1
					if a=2 : ehitcheck 7,0,1
					enemy_anipc(ecnt)++
					if enemyl(cnt)=0 : dmmplay sesound(12)//死亡音
				}
			}
*enemy_mouse
			if a=3{//もしネズミなら〜
				;logmes "通った"
				epos bsize/2,bsize : color 243,0,255
				if enemyl(ecnt)=0{//死んでたら
					if edcnt(ecnt)<8{//一定時間描画
						edcnt(ecnt)++
						if enemydir(ecnt)=0{//もし左向きだったら〜
							celput mainpic(8),enemy_num(a)+(enemy_anip(a)/2)-1
						}
						if enemydir(ecnt)=1{//もし右向きだったら〜
							celput mainpic(8),enemy_num(a)+enemy_anip(a)-1
						}
					}
				}
				if enemyl(ecnt)>0{//生きてたら
					enemy_info 20,40,43,63
					if enemydir(ecnt)=0 & edcheck(ecnt)=0{//もし左向きだったら〜
						if enemy_mode(ecnt)=0{
							exmove(ecnt)=0.0
							celput mainpic(8),enemy_num(a)+((enemy_anipc(ecnt)/20)\((enemy_anip(a)/2)-1))
							enemypx(ecnt)-0.2 : ebh 0,0,0,255,0 : d=stat; : logmes "d="+d
							//if d=0 : ブロックがなかったら移動させる
							if d!0 : enemydir(ecnt)=1 : enemy(ecnt)+0.2 : edcheck(ecnt)=1
						}
						if enemy_mode(ecnt)=1{
							celput mainpic(8),enemy_num(a)+((enemy_anipc(ecnt)/5)\((enemy_anip(a)/2)-1))
							ebh 0,0,0,255,0 : d=stat; : logmes "d="+d//左にブロックがあるか
							//if d=0 : ブロックがなかったら移動させる
							if d=0 : exmove(ecnt)=-4.0
						}
						;左方向の索敵
						mapx=int(enemypx(ecnt)-enemy_pos_x1+ebhpx1)/bsize+mapvmv : mapy=int(enemypy(ecnt)-enemy_pos_y1+ebhpy1)/bsize+mapvmv : c=map(mapx,mapy)
						repeat enemycmx(ecnt) : ccnt=cnt : b=0//進行方向のブロック数分を調べる
							repeat pbhl_str_vol
								if mapx-ccnt-2<mapvmv : break//はみ出るなら調べない
								if map(mapx-ccnt,mapy)=pbhl_str(cnt) : b=1 : break//あったらb=1にする
							loop
						if b=0{//ブロックがなかった
							;logmes "敵の左="+((mapx-ccnt-1)*bsize)+"<=自分の右="+(px+pbhpx2)+" 敵の右="+((mapx-ccnt)*bsize)+">自分の左="+(px+pbhpx1)
							;logmes "敵の上="+((mapy-1)*bsize)+"<=自分の下="+(py+pbhpy2)+" 敵の下="+((mapy)*bsize)+">自分の上="+(py+pbhpy1)
							if (mapx-ccnt-1)*bsize<=px+pbhpx2 & (mapx-ccnt)*bsize>px+pbhpx1 & (mapy-1)*bsize<=py+pbhpy2 & (mapy)*bsize>py+pbhpy1{
								enemy_mode(ecnt)=1//プレイヤーがいたら
								;logmes  "目の前にいるな！？"
								break
								}else : enemy_mode(ecnt)=0; : logmes "目の前にいないなぁ..."//プレイヤーがいなかったら
						}
						if b=1 : break
						loop
					}
					if enemydir(ecnt)=1 & edcheck(ecnt)=0{//もし右向きだったら〜
						if enemy_mode(ecnt)=0{
							exmove(ecnt)=0.0
							celput mainpic(8),enemy_num(a)+((enemy_anipc(ecnt)/20)\((enemy_anip(a)/2)-1))+enemy_anip(a)/2
							enemypx(ecnt)+0.2 : ebh 2,0,0,255,0 : d=stat; : logmes "d="+d
							//if d=0 : ブロックがなかったら移動させる
							if d!0 : enemydir(ecnt)=0 : enemy(ecnt)-0.2 : edcheck(ecnt)=1
						}
						if enemy_mode(ecnt)=1{
							celput mainpic(8),enemy_num(a)+((enemy_anipc(ecnt)/5)\((enemy_anip(a)/2)-1))+enemy_anip(a)/2
							ebh 2,0,0,255,0 : d=stat; : logmes "d="+d//左にブロックがあるか
							//if d=0 : ブロックがなかったら移動させる
							if d=0 : exmove(ecnt)=4.0
						}
						;右方向の索敵
						mapx=int(enemypx(ecnt)-enemy_pos_x1+ebhpx2)/bsize+mapvmv : mapy=int(enemypy(ecnt)-enemy_pos_y1+ebhpy1)/bsize+mapvmv : c=map(mapx,mapy)
						if enemypx(ecnt)-enemy_pos_x1+ebhpx2>msx : enemydir(ecnt)=0 : edcheck(ecnt)=1
						repeat enemycmx(ecnt) : ccnt=cnt : b=0//進行方向のブロック数分を調べる
							repeat pbhr_str_vol
								if mapx+ccnt-1<mapvmv : break//はみ出るなら調べない
								if map(mapx+ccnt,mapy)=pbhr_str(cnt) : b=1 : break//あったらb=1にする
							loop
						if b=0{//ブロックがなかった
							;logmes "敵の左="+((mapx-ccnt)*bsize)+"<=自分の右="+(px+pbhpx2)+" 敵の右="+((mapx-ccnt+1)*bsize)+">自分の左="+(px+pbhpx1)
							;logmes "敵の上="+((mapy-1)*bsize)+"<=自分の下="+(py+pbhpy2)+" 敵の下="+((mapy)*bsize)+">自分の上="+(py+pbhpy1)
							if (mapx+ccnt-1)*bsize<=px+pbhpx2 & (mapx+ccnt)*bsize>px+pbhpx1 & (mapy-1)*bsize<=py+pbhpy2 & (mapy)*bsize>py+pbhpy1{
								enemy_mode(ecnt)=1//プレイヤーがいたら
								;logmes  "目の前にいるな！？"
								break
								}else : enemy_mode(ecnt)=0; : logmes "目の前にいないなぁ..."//プレイヤーがいなかったら
						}
						if b=1 : break
						loop
					}
					;logmes "enemy_mode="+enemy_mode(ecnt)
					;左右移動
					;logmes "exmove="+exmove(ecnt)
					repeat abs(exmove(ecnt))
						if exmove(ecnt)<0{//左へ移動している
							ebh 0,0,255,0,100 : d=stat; : logmes "d="+d
							if d=0 : enemypx(ecnt)-1
							if d!0 : enemydir(ecnt)=1 : edcheck(ecnt)=1 : break//向きを変える
						}if exmove(ecnt)>0{//右へ移動している
							ebh 2,0,0,255,100 : d=stat; : logmes "d="+d
							if d=0 : enemypx(ecnt)+1
							if d!0 : enemydir(ecnt)=0 : edcheck(ecnt)=1 : break//向きを変える
						}
					loop
					;logmes "enemydir="+enemydir(ecnt)
					;logmes "終わり！"
					;上下移動
					ebh 3 : d=stat
					if d=0 : eymove(ecnt)+1//地面がなかったら
					repeat abs(eymove(ecnt))
						if eymove(ecnt)<0{//上昇中だったら
							ebh 1,0,255,100,255 : d=stat
							if d=0 : enemypy(ecnt)-1
							if d!0 : eymove(ecnt)=0 : break
						}if eymove(ecnt)>0{//下降中だったら
							ebh 3,0,0,255,255 : d=stat
							if d=0 : enemypy(ecnt)+1
							if d!0 : eymove(ecnt)=0 : break
						}
					loop
					ehitcheck 3,0,1
					enemy_anipc(ecnt)++
					if enemyl(cnt)=0 : dmmplay sesound(12)//死亡音
				}
			}
			edcheck(ecnt)=0
		}
		if (enemypx(ecnt)<-wx_move-bsize*5 | -wx_move+gwx+bsize*5<=enemypx(ecnt) | enemypy(ecnt)<-wy_move-bsize*5 | -wy_move+gwy+bsize*5<=enemypy(ecnt)) & enemyl(ecnt)!0{//画面外に出てちょっと離れて　かつ　死んでなかったら
			if -wx_move-bsize*5>fenemypx(ecnt) & fenemypx(ecnt)>=-wx_move+gwx+bsize*5 & -wy_move-bsize*5>fenemypy(ecnt) & fenemypy(ecnt)>=-wy_move+gwy+bsize*5 : enemypx(ecnt)=fenemypx(ecnt) : enemypy(ecnt)=fenemypy(ecnt) : //かつ復帰場所が画面外だったら元の位置に戻す
		}
	loop
	if canjump=1{
		if space=0 : pymove=-pymovem/2//ジャンプ高さ低め
		if space=1 : pymove=-pymovem-2//ジャンプ高さ高め
	}
return

*player_draw
		;描画
	if player_damage_mode=1{
		pdcnt++//player_damage_cnt
		if pdcnt=127 : player_damage_mode=0 : pdcnt=0
	}
	;logmes "pdcnt="+pdcnt
	color 243,0,255 : gmode 4,,,ptrans//プレイヤーを描画
	if pdcnt\4!1{//点滅にするため
		if pg=0 | pg=4 :  pos px+wx_move,py+wy_move : celput mainpic(2),pani
		if pg=2 : pos px+wx_move,py+wy_move : celput mainpic(2),pani,,,deg2rad(180)
	}
	if pdeath=1 : return//死んでたら描画だけ
	panic++//player_animation_check
		;左右
	;pxymovep_cnt++//加速、減速のしやすさ用
	if hidari=1 & acnt\pxmovep=0 : pxmove-1 : hidarip=1 : if migip=0 : px_direction=0//pxmove--
	if hidari=0 : hidarip=0
	if migi=1 & acnt\pxmovep=0 : pxmove+1 : migip=1 : if hidarip=0 : px_direction=1//pxmove++
	if migi=0 : migip=0
	if (hidari=0 & migi=0) | (hidari=1 & migi=1){
		if pxmove<0 & acnt\pxmovep=0 : pxmove++
		if pxmove>0 & acnt\pxmovep=0 : pxmove--
		if px_direction=0{
			if panic\panipf(0)=0{//アニメーション用
				if (pg=0 | pg=4) : pani=loopan(pani,panip(0),panip(1))//下
				if (pg=2) : pani=loopan(pani,panip(1),panip(2))//上
			}
		}if px_direction=1{
			if panic\panipf(0)=0{//アニメーション用
				if (pg=0 | pg=4) : pani=loopan(pani,panip(1),panip(2))//下
				if (pg=2) : pani=loopan(pani,panip(0),panip(1))//上
			}
		}
		//logmes "pacheck="+pacheck
	}
	pxmove=limit(pxmove,-pxmovem,pxmovem)//pxmoveを決定
	
	repeat abs(pxmove)
		if pxmove<0{//左に移動
			pbh 0,0,255,0,255 : a=stat
			if a=0 : px-1//ブロックがなかったら移動
			if a>0 : px_move=0//ブロックがあったら減速
			//if a>0 : pxmove+1
		}if pxmove>0{//右移動
			pbh 2,0,0,255,0 : a=stat
			if a=0 : px+1//ブロックがなかったら移動
			if a>0 : px_move=0//ブロックがあったら減速
		}
		px=limit(px,-pbhpx1,msx-pbhpx2)//pxを決定
	loop
	if pxmove<0{//左向きのアニメーション
		if panic\panipf(3)=0{
			if (pg=0 | pg=4){//下
				if pani<panip(2) | panip(4)<=pani : pani=panip(2)//ani:初期動作
				if pani<panip(3) : pani++
				if panip(3)<=pani & pani<panip(4) : pani=loopan(pani,panip(3),panip(4))//ani:走り続ける
			}if (pg=2){//上
				if pani<panip(4) | panip(6)<=pani : pani=panip(4)//ani:初期動作
				if pani<panip(5) : pani++
				if panip(5)<=pani & pani<panip(6) : pani=loopan(pani,panip(5),panip(6))//ani:走り続ける
			}
		}
	}if pxmove>0{//右向きのアニメーション
		if panic\panipf(3)=0{
			if (pg=0 | pg=4){//下
				if pani<panip(4) | panip(6)<=pani : pani=panip(4)//ani:初期動作
				if pani<panip(5) : pani++
				if panip(5)<=pani & pani<panip(6) : pani=loopan(pani,panip(5),panip(6))//ani:走り続ける
			}if (pg=2){//上
				if pani<panip(2) | panip(4)<=pani : pani=panip(2)//ani:初期動作
				if pani<panip(3) : pani++
				if panip(3)<=pani & pani<panip(4) : pani=loopan(pani,panip(3),panip(4))//ani:走り続ける
			}
		}
	}

	//logmes "pani="+pani
		;上下
	;ジャンプ
	if pswim=0{
		;logmes "spacep="+spacep
		if space=1 & spacep=0{
			;logmes "ジャンプした
			spacep=1 : dmmplay sesound(7)
			if pymove>0 : pymove=0
			repeat pymovem
				getkey spacea,32
				if spacea=1 & pymove>-pymovem : pymove-1
			loop
		}
		;重力
		if (pg=0 | pg=4){//下
			pbh 3,0,255,0,0 : a=stat
			;logmes "地面のリターン値="+a
			if a=0 & pymove<pymovem  & acnt\pymovep=0{//地面がなかったら
				if pg=0 & pymove<pymovem : pymove+1
				if pg=4 & pymove<pymovem : pymove+2
				if spacep=1{
					if pxmove<0 : pani=panip(6)//ジャンプ中のアニメーション(左)
					if pxmove>0 : pani=panip(7)//(右)
				}
			}if a>0{
				;dmmplay sesound(9)
				spacep=0//再ジャンプ可能に
			}//再ジャンプ可能に
		}if pg=2{//上
			pbh 1,0,255,0,0 : a=stat
			if a=0 & pymove<pymovem{//地面がなかったら
				if pymove<pymovem : pymove+1
				if spacep=1{
					if pxmove<0 : pani=panip(7)//ジャンプ中のアニメーション(左)
					if pxmove>0 : pani=panip(6)//(右)
				}
			}if a>0{
				;if pymove!0 : dmmplay sesound(9)
				spacep=0//再ジャンプ可能に
			}
		}
	}if pswim=1{
		if space=1 & spacep=0{
			dmmplay sesound(16) : spacep=1
			repeat pymovem/3
				getkey space,32
				if space=1 & pymove>-pymovem : pymove-1
				;logmes "pymovre="+pymove
			;await 1
			loop
		}
		pbh 3,0,255,0,0 : a=stat
		;logmes "地面のリターン値="+a
		if a=0 & pymove<pymovem/4  & acnt\pymovep=0{//地面がなかったら
			if pymove<pymovem : pymove+1
			if spacep=1{
				if pxmove<0 : pani=panip(6)//ジャンプ中のアニメーション(左)
				if pxmove>0 : pani=panip(7)//(右)
			}
		}if space=0 : spacep=0
	}
	
	;logmes "pymove="+pymove
	repeat abs(pymove)//上昇、下降回数分リピート
		if (pg=0 | pg=4){
			if pymove<0{//上昇中だったら
				pbh 1,0,100,10,255 : a=stat
				if a=0 : py-1
				if a>0 : pymove=0 : break//何かにぶつかったら落下させる
			}
			if pymove>0{//下降中だったら
				pbh 3,0,255,0,0 : a=stat
				if a=0 : py+1//地面がなかったら
				if a>0 : pymove=0 : break//地面があったら
			}
		}
		if (pg=2){
			if pymove<0{//上昇中だったら
				pbh 3,0,100,10,255 : a=stat
				if a=0 : py+1
				if a>0 : pymove=0 : break//何かにぶつかったら落下させる
			}
			if pymove>0{//下降中だったら
				pbh 1,0,255,0,0 : a=stat
				if a=0 : py-1//地面がなかったら
				if a>0 : pymove=0 : break//地面があったら
			}
		}
		;pymove=limit(pymove,-pymovem,pymovem)//pymoveを決定
	loop
	py=limit(py,-psizey-bsize,msy+psizey)//pyを決定
	//py=limit(py,0,msy)
	pbh 4,0,255,255,0
return

*player_UI
	drphit_damage
	;HPバー
	color 255,100,100 : boxf 32,0,32+limit(double(player_hp)/player_hpm*167,0,200),19//HPのバー
	player_hp=limit(player_hp,0,player_hpm)
	color 243,0,255 : gmode 4,,,255 : pos 0,0 : celput mainpic(11)//HPの画像
	font "",14
	color 0,0,0 : pos 202,4 : mes ""+player_hp+"/"+player_hpm
	;小魂カウンター
	gmode 0 : pos 250,0 : celput mainpic(14) : pos 380,4 : mes kodama_vol
	
return

*pose_menu
	bb=0
	repeat
		redraw 1 : redraw 0
		color 243,0,255 : gmode 4,,,cnt : pos 0,0 : celput mainpic(15)
		gmode 4,,,limit(cnt,0,100) : pos 0,0 : celput mainpic(16)
		pos 0,0 : celput mainpic(17)

		gosub*keycontrol
		if ue=1 : bb=0
		if sita=1 : bb=1
		ga=ginfo_act
		if (360<moux & moux<672 & 192<mouy & mouy<288) & ga!-1 & check=0 : bb=0 : check=1 : if lclick=1 : break
		if (352<moux & moux<672 & 352<mouy & mouy<448) & ga!-1 & check=0 : bb=1 : check=1 : if lclick=1 : break
		if bb=0 : color 243,0,255 : gmode 4,,,limit(cnt,0,255) : pos 0,0 : celput mainpic(16)
		if bb=1 : color 243,0,255 : gmode 4,,,limit(cnt,0,255) : pos 0,0 : celput mainpic(17)
		if enter=1 & ga!-1 : break
		check=0
		await 16
	loop
	if bb=1{
		if play_mode=0 : vs_nest=1 : back_to_select=1
		if play_mode=1 : vs_nest=1 : back_to_select=1
		if play_mode=2{
			if stage_map_name="" : vs_nest=1 : back_to_select=1
			if stage_map_name!"" : vs_nest=1 : back_to_select=2
			logmes "back"+back_to_select
		}
	}
return

*get_big_soul
	gmode 2 : pos px+pbhpx1,py+pbhpy-400 : celput effepic(4),acnt\250
return

*player_mode
	if pg=0{//通常
		if pmode=0 : pbh_info 17,5,40,64
	}
	if pg=1{//左
		if pmode=0 : pbh_info 17,5,40,64
	}
	if pg=2{//上
		if pmode=0 : pbh_info -17,-5,-40,-64
	}
	if pg=3{//右
		if pmode=0 : pbh_info 17,5,40,64
	}
	if pg=4{//下
		if pmode=0 : pbh_info 17,5,40,64
	}
	//logmes "px="+px+" py="+py
return

*pdeath_check
	if py>msy | player_hp=0 : pdeath=1 : vs_nest=1
return

*stage_clear
	dmmstop -1//音楽停止
	dmmplay sesound(3)
	a=0//背景を表示させるフレート数
	gosub*map_draw : gosub*player_draw : gosub*player_UI
	repeat
		redraw 1 : redraw 0
		acnt=cnt
		if (cnt-a)*14-gwx*2<gwx : color 0,0,0 : gmode 4,,,5-acnt/60 : pos (goalx-mapvmv)*bsize+wx_move,(goaly-mapvmv)*bsize+wy_move : celput effepic(0),(acnt/2)\200//ぼんやり光る
		color 255,255,255 : gmode 4,,,10 : pos (cnt-a)*14-gwx*3,0 : celput mainpic(4)//グラデーション背景
		if (cnt-a)*14-gwx*4>gwx : break//グラデーションが画面台に出たらステージ選択画面へ
		if (cnt-a)*14-gwx*3>=gwx : color 0,0,0 :gmode 2
		
		gosub*keycontrol
		if space=1 : break
		await 16
	loop
	if play_mode=0{
		;px=fpx : py=fpy//初期位置に戻す
		play_mode=1 : mload_mode=3 : gosub*map_load : goto*play_select
	}
	if play_mode=2{
		if first_story=1 : first_story=2
		akodama_vol+=kodama_vol
		kodama_vol=0
		wx_move=gwx/2-px : wy_move=gwy/2-py : goto*stage_select_main
	}
*menu_death
	dmmstop -1//音楽停止
	dmmplay sesound(2)//死亡音
	sflame=120//start_flame//BGMを流すフレーム数
	bb=0 : player_damage_mode=0 : pdcnt=0 : kodama_vol=0 : pswim=0 : pymovep=1
	repeat
		redraw 1 : redraw 0
		if cnt=sflame : dmmplay bgmsound(2)//死亡時BGM再生
		if cnt<sflame{
			gosub*map_draw
			gosub*enemy_draw
			;logmes ""+(sflame/panipc(8))
			if px_direction=0 : pani=panip(8)+cnt/(sflame/panipc(8))
			if px_direction=1 : pani=panip(9)+cnt/(sflame/panipc(9))
			gosub*player_draw　: ptrans-1
			gosub*player_UI
		}
		if cnt>sflame{
			gmode 3,,,(cnt-a)/5 : pos 0,0 : celput mainpic(3)
			color 243,0,255 : gmode 4,,,limit((cnt-a)/5,0,50) : pos 0,0 : celput mainpic(6) : pos 0,0 : celput mainpic(7)
			gosub*keycontrol
			if hidari=1 : bb=0
			if migi=1 : bb=1
		}

		ga=ginfo_act
		if (110<moux & moux<430 & 380<mouy & mouy<550) & ga!-1 & check=0 : bb=0 : check=1 : if lclick=1 : break
		if (570<moux & moux<880 & 380<mouy & mouy<550) & ga!-1 & check=0 : bb=1 : check=1 : if lclick=1 : break
		if bb=0 : color 243,0,255 : gmode 4,,,(cnt-a)/5 : pos 0,0 : celput mainpic(6)
		if bb=1 : color 243,0,255 : gmode 4,,,(cnt-a)/5 : pos 0,0 : celput mainpic(7)
		if enter=1 & ga!-1  : break
		check=0
		await 16
	loop
	if px_direction=0 : pani=panip(0)
		if px_direction=1 : pani=panip(1)
	ptrans=255 : dmmstop -1
	if bb=0{
		if play_mode=0 : px=fpx : py=fpy : mload_mode=3 : gosub*map_load : gosub*map_bgm : goto*main//もっかい遊ぶ
		if play_mode=2 : mload_mode=1 : gosub*map_load : gosub*map_bgm : goto*main
	}
	if bb=1{//いいえ
		if play_mode=0 : play_mode=1 : mload_mode=3 : gosub*map_load : gosub *map_bgm : wait 10 : wx_move=gwx/2-px : wy_move=gwy/2-py : goto*play_select//作るモードに変える
		if play_mode=2{
			repeat 64 : redraw 1 : redraw 0 : pos 0,0 : celput mainpic(3) : black_inout cnt,0 : loop
			wx_move=gwx/2-px : wy_move=gwy/2-py : goto*stage_select_main
			
		}
	}

*mplayer_draw
	if lclick=1 & phold=0 & (px+pbhpx1)+wx_move<=moux & moux<(px+pbhpx2)+wx_move & (py+pbhpy1)+wy_move<=mouy & mouy<(py+pbhpy2)+wy_move : phold=1
	if phold=1 & lclick=0 : phold=0
	if phold=1{
		px=moux-wx_move-pbhpx1-psizex/2 : py=mouy-wy_move-pbhpy1-psizey/2
	}
	px=limit(px,-pbhpx1,msx-pbhpx2) : py=limit(py,-pbhpy1,msy-pbhpx2)//制限
	color 243,0,255 : gmode 4,,,255
	pos px+wx_move,py+wy_move : celput mainpic(2),pani//プレイヤーを描画
return

*makeUI//!!////////////////UI部分は定数が多いから変更する際は注意！！///////////////////////!!//
		;右側のUI
	;後ろ
		if mouw>0 : sUI-1//マウスホイール
		if mouw<0 : sUI+1//マウスホイール
		if 710<=moux & moux<970 & 0<=mouy & mouy<=14 & phold=0{
		if lclick=1{
			if 710<=moux & moux<800 : sUI=0
			if 800<=moux & moux<890 : sUI=1
			if 890<=moux & moux<980 : sUI=2
		}
	}sUI=limit(sUI,0,2)//select_UI
	color 243,0,255 : gmode 4,,,230
	if sUI=0 : pos bsize*22,0 : celput makepic(0)
	if sUI=1 : pos bsize*22,0 : celput makepic(1)
	if sUI=2 : pos bsize*22,0 : celput makepic(2)
	;ブロック
	color 243,0,255 : gmode 4,,,255
	if sUI=0{
		if sb_mode!0 : sb_mode=0 : sblock=block_str(0) : select_target=0 : sblock=cblock_str(0)
		repeat cblock_num_vol+block_mnum_vol
			pos 736+(cnt\8)*bsize,32+(cnt/8)*bsize
			if cnt<cblock_num_vol{
				celput mainpic(0),cblock_num(cnt)//connectブロックをUIに配置
				if lclick=1 & 736+(cnt\8)*bsize<=moux & moux<736+((cnt\8)+1)*bsize & 32+(cnt/8)*bsize<=mouy & mouy<32+((cnt/8)+1)*bsize{//もしブロックを選んでいたら
					sblock=cblock_str(cnt) : select_target=cnt
					//logmes "選択したブロックは"+sblock
					sb_mode=0
				}
			}
			if cblock_num_vol<=cnt{
				celput mainpic(1),block_mnum(cnt-cblock_num_vol)//普通のブロックをUIに配置
				if lclick=1 & 736+(cnt\8)*bsize<=moux & moux<736+((cnt\8)+1)*bsize & 32+(cnt/8)*bsize<=mouy & mouy<32+((cnt/8)+1)*bsize{//もしブロックを選んでいたら
					sblock=block_mstr(cnt-cblock_num_vol) : select_target=cnt
					//logmes "選択したブロックは"+sblock
				}
			}
		loop
	}
	;ほかのブロック
	if sUI=1{
		if sb_mode!1 : sb_mode=1 : sblock=oblock_str(0) : select_target=0 : sblock=oblock_str(0)
		repeat oblock_num_vol
			//logmes "cnt="+cnt
			pos 736+(cnt\8)*bsize,32+(cnt/8)*bsize
			celput mainpic(5),oblock_num(cnt)//普通のブロックをUIに配置
			if lclick=1 & 736+(cnt\8)*bsize<=moux & moux<736+((cnt\8)+1)*bsize & 32+(cnt/8)*bsize<=mouy & mouy<32+((cnt/8)+1)*bsize{//もしブロックを選んでいたら
				sblock=oblock_str(cnt) : select_target=cnt
				//logmes "選択したブロックは"+sblock
			}
		loop
	}
	;敵
	if sUI=2{
		if sb_mode!2 : sb_mode=2 : sblock=oblock_str(0) : select_target=0 : sblock=enemy_str(0)
		repeat enemy_mnum_vol
			pos 736+(cnt\8)*bsize-bsize/2,32+(cnt/8)*bsize-bsize//ちょっとずらして配置（元が64*64だから）
			celput mainpic(8),enemy_num(cnt)//普通のブロックをUIに配置
			if lclick=1 & 736+(cnt\8)*bsize<=moux & moux<736+((cnt\8)+1)*bsize & 32+(cnt/8)*bsize<=mouy & mouy<32+((cnt/8)+1)*bsize{//もしブロックを選んでいたら
				sblock=enemy_str(cnt) : select_target=cnt
				//logmes "選択した敵は"+sblock
			}
		loop
	}
	color acnt*3,acnt*3,acnt*3
	boxline 736+(select_target\8)*bsize,32+(select_target/8)*bsize,736+(select_target\8+1)*bsize-1,32+(select_target/8+1)*bsize-1//選択したブロックに点滅する枠を表示
	
	;mx,myを変更//repeat-loop外で記入
	//pos 730,492 : input mx,40,20,3 : pos 730,535 : input my,40,20,3//↑の記入内容
	font "",15
	color 0,0,0 : pos 730,480 : mes "横サイズ" : color 0,0,0 : pos 730,518 : mes "縦サイズ"
	pos 800,510 : mes "F3で\n  モード切替"
	;ボタン
	ssmenu 0//button表示
	a=stat
	//logmes "a="+a
	if phold=0{
		if a=0 : menu=1 : vs_nest=1//読み込み
		if a=1 : menu=2 : vs_nest=1//名前を付けて保存
		if a=2 : menu=3 : vs_nest=1//上書き保存
		if a=3{//画面の真ん中に再表示
			px=gwx/2-wx_move : py=gwy/2-wy_move
			if px_direction=0 : pani=panip(0)
			if px_direction=1 : pani=panip(1)
		}
		if a=4{//まっさらにする
			menu=4 : vs_nest=1
			if px_direction=0 : pani=panip(0)
			if px_direction=1 : pani=panip(1)
		}
	}
return

*anything_set
	ga=ginfo_act
	repeat my
		ycnt=cnt
		repeat mx
			xcnt=cnt : check=0
			//logmes "x="+(bsize*xcnt)+"〜"+(bsize*(xcnt+1))
			if bsize*xcnt+wx_move<=moux & moux<bsize*(xcnt+1)+wx_move & bsize*ycnt+wy_move<=mouy & mouy<bsize*(ycnt+1)+wy_move & moux<=710 & ga!-1{//その枠内で〜
				if lclick=1 & check=0 & phold=0{//左クリック+プレイヤーホールドしてない状態だったら
					mapx=xcnt+mapvmv : mapy=ycnt+mapvmv
					if sb_mode=0{//ブロック
						c=map(mapx,mapy)
						;logmes "設置したx="+mapx+" y="+mapy
						if fill_mode=0 & c!sblock{//普通に設置
							if sblock="b(3)" : map(goalx,goaly)="0" : goalx=mapx : goaly=mapy//ゴールは一個しか置けないように
							dmmplay sesound(0) :map(mapx,mapy)=sblock//設置
							//if omap(mapx,mapy)!"0" : omap(mapx,mapy)="0"
							;logmes "設置したブロックは"+sblock+"です
						}
						if fill_mode=1 & c!sblock & sblock!"b(3)" : anything_fill sblock//塗りつぶしモードだったら
					}
					if sb_mode=1{//その他ブロック
						;logmes "設置したx="+mapx+" y="+mapy
						c=omap(mapx,mapy)
						if fill_mode=0 & c!sblock{//普通に設置
							dmmplay sesound(0) : omap(mapx,mapy)=sblock//設置
							;logmes "設置したブロックは"+sblock+"です
						}
						if fill_mode=1 & c!sblock : anything_fill sblock//塗りつぶしモードだったら
					}
					if sb_mode=2{//敵
						;logmes "設置したx="+mapx+" y="+mapy
						c=emap(mapx,mapy)
						if map(mapx,mapy)!"0" : map(mapx,mapy)="0"
						if omap(mapx,mapy)!"0" : omap(mapx,mapy)="0"
						if c!sblock : dmmplay sesound(0) : emap(mapx,mapy)=sblock : lclickp=1; : logmes "設置した敵は"+sblock+"です//設置
						if c=sblock & lclickp=0 : dmmplay sesound(15) : edmap(mapx,mapy)++ : lclickp=1//設置
					}
					map_change=1
				}if lclick=0 : lclickp=0
				if rclick=1{//右クリックされたら
					mapx=xcnt+mapvmv : mapy=ycnt+mapvmv : check=0
					//logmes "削除したx="+mapx+" y="+mapy
					if sb_mode=0 : c=map(mapx,mapy)
					if sb_mode=1 : c=omap(mapx,mapy)
					if sb_mode=2 : c=emap(mapx,mapy)
					if fill_mode=0{
						;logmes "c="+c
						if sb_mode=0 & c!"0" : map(mapx,mapy)="0" : check=1
						if sb_mode=1 & c!"0" : omap(mapx,mapy)="0" : check=1
						if sb_mode=2 & c!"0" : emap(mapx,mapy)="0" : edmap(mapx,mapy)=0 : check=1
						if check=1 : dmmplay sesound(1)
						
					}
					if fill_mode=1 & c!"0" : anything_fill "0"//塗りつぶしモードだったら
					map_change=1
				}
			}
		loop
	loop
return

*clean_map
	;logmes "マップを一掃しました"
	mapdata="" : mapinfo="" : omapdata="" : emapdata=""
	repeat mymax
		ycnt=cnt+mapvmv
		repeat mxmax
			xcnt=cnt+mapvmv
			map(xcnt,ycnt)="0" : animap(xcnt,ycnt)=0 : animapc(xcnt,ycnt)=0
			omap(xcnt,ycnt)="0"
			emap(xcnt,ycnt)="0" : edmap(xcnt,ycnt)=0 : ecmxmap(xcnt,ycnt)=0 : ecmymap(xcnt,ycnt)=0
		loop
	loop
	goalx=0 : goaly=0
return

*map_load//マップ読み込み
		;読み込み
	;フォルダ検索
	if mload_mode=-1 : gosub*clean_map : return//何も読み込まない
	if mload_mode=0 : fname="map/new"//最初に読み込みファイルを指定しない場合
	if mload_mode=1 : fname="map/stage_select/"+stage+"/"+stage_map_name//最初から選択する場合
	if mload_mode=2{
		dialog "phs",16
		if stat=0 : mload_mode=3 : black_mode=0 : wait 10 : return// : dialog "読み込みに失敗しちゃったぁ...",0
		a=refstr
		repeat//フォルダ名を検索
		if strmid(a,cnt,11)="Clickme.phs" : fname=strmid(a,0,cnt-1) : break//選択する場合のfname
		loop
		gosub*clean_map//無事読み込めたらマップをリセット
	}
	if mload_mode=3 : ffname=fname : fname="temp"//tempファイル
	;if mload_mode=4//事前に指定したfnameを読み込む
	;ステージ情報
	if mload_mode!3{
		mapinfo="" : notesel mapinfo
		logmes fname+"/info.txtを読み込み"
		noteload fname+"/info.txt" : a=0
		noteget mx,a : a++ : noteget my,a : a++ : noteget px,a : a++ : noteget py,a : a++
		mx=int(mx) : my=int(my) : fpx=int(px) : fpy=int(py) : px=int(px) : py=int(py)
	}
	;logmes fname+"読み込み"
	;ブロック
	notesel mapdata//バッファ指定
	noteload fname+"/stage.txt"
	c=""
	repeat my
		//redraw 0 : drawc=1//読み込み風景を描画する@
		ycnt=cnt : xload=0
		noteget a,ycnt//aに一時的にその行の内容を代入する
		;logmes ""+ycnt+"行目="+a
		repeat mx
			xcnt=cnt
			b=strmid(a,xload,1)//b:確認用に一時的に入れる
			c=b//何もなければ空気//c:最終的にmap(mx,my)に代入する
			
			if (b="a" | b="b"){//カッコつきの奴だったら
				repeat
					ccnt=cnt//何文字目まで数字かを、代入する
					if strmid(a,xload+ccnt+2,1)=")" : break
				loop
				c=strmid(a,xload,ccnt+3) : xload+ccnt+2
				if c="b(3)" : goalx=xcnt+mapvmv : goaly=ycnt+mapvmv//ゴールだったら座標を登録
			}
			map(xcnt+mapvmv,ycnt+mapvmv)=c//ブロック情報を代入
			xload++
			if drawc=1 : pos bsize*xcnt,bsize*ycnt : color 0,0,0 : mes c
			//logmes ""+ycnt+"行目の"+xcnt+"文字目="+c
			//redraw 1 : await 10//読み込み風景を描画するA
		loop
		//redraw 1 : await 50//読み込み風景を描画するA
	loop
	
	;その他ぶろっく
	omapdata=""
	notesel omapdata//バッファ指定
	noteload fname+"/ostage.txt"
	repeat my : ycnt=cnt : xload=0 : noteget a,ycnt : repeat mx : xcnt=cnt : b=strmid(a,xload,1) : c=b
		if b="c"{
			repeat ccnt=cnt : if strmid(a,xload+ccnt+2,1)=")" : break : loop
			c=strmid(a,xload,ccnt+3) : xload+ccnt+2
		}omap(xcnt+mapvmv,ycnt+mapvmv)=c : xload++
	loop : loop

	;敵
	emapdata=""
	notesel emapdata//バッファ指定
	noteload fname+"/estage.txt"
		nm=notemax : xload=0 : enemy_vol=0
		;gosub *enemy_dim
		repeat nm//行数分データー読み込み
			ycnt=cnt : xload=0
			noteget a,ycnt//ycnt行目の内容をaに代入
			;logmes "a="+a
			repeat 6//一体分のデーター
				ccnt=cnt : c=strmid(a,xload,1)
				;logmes c
				if ccnt=0 & c=";" : break//読み込まない
				repeat
					c=strmid(a,xload+(cnt+1),1)
					if c="," : edata(ccnt)=int(strmid(a,xload,cnt+2)) : xload+cnt+2 : break
					if c="" : ccnt=5 : edata(ccnt)=int(strmid(a,xload,cnt+2)) :: break
				loop
			loop
			;logmes "number="+edata(0)+" direction="+edata(1)+" posx="+edata(2)+" posy="+edata(3)+" canmovex="+edata(4)+" canmovey="+edata(5)
			;logmes "play_mode="+play_mode
			if play_mode=1{//作るモードだったら
				;logmes "通った"
				edata(2)=limit(edata(2),mapvmv,mx+mapvmv) : edata(3)=limit(edata(3),mapvmv,my+mapvmv)//上限をつける
				mapx=edata(2)+mapvmv : mapy=edata(3)+mapvmv//登録するマス
				emap(mapx,mapy)="e("+edata(0)+")" : edmap(mapx,mapy)=edata(1) : ecmxmap(mapx,mapy)=edata(4) : ecmymap(mapx,mapy)=edata(5)//敵の種類とか
				;logmes "読み込み時のemap="+emap(mapx,mapy)
			}if play_mode=0 | play_mode=2 : mkenemy edata.0,edata.1,edata.2,edata.3,edata.4,edata.5//遊ぶモードだったら
		loop
		if mload_mode=3 : fpx=px : fpy=py : fname=ffname
		;mload_mode=4
return

*map_save
	;logmes "msave_move="+msave_mode
	;通常ブロック
	mapdata="" : mapinfo="" : omapdata="" : emapdata="" : notesel mapdata 
	goalcheck=0//ゴールの有無を確認
	repeat my
		ycnt=cnt+mapvmv : mapd=""
		repeat mx
			xcnt=cnt+mapvmv
			c=map(xcnt,ycnt)
			mapd+=c
			if c="b(3)" : goalcheck=1 : goalx=xcnt : goaly=ycnt; : logmes "goalx="+goalx+" goaly="+goaly//ゴールがあったら座標を保存
		loop
		noteadd mapd,-1,0
	loop
	
	if goalcheck=0 : dialog "灯篭（ゴール）が設置されていません",1 : black_mode=0 : wait 10 : goto*mmain//ゴールがなかったら保存させない
	if msave_mode=0{
		fffname=ffname
		dialog "phs",17 : ffname=refstr : a=stat//名前を付けて保存
		if a=0 : wait 10 : black_mode=0 : ffname=fffname : msave_mode=check : goto*mmain//: dialog "保存に失敗したお^ω^",1 : //保存に失敗したら
		if a!0{//保存に成功したら〜
			;ffnameの後ろに"/Clickme.phs"がなければexistにつけて、なければつけないで保存
			d=strmid(ffname,-1,11)
			if d="Clickme.phs"{
				;logmes "調べたファイル名"+ffname
				exist ffname : c=strsize
			}if d!"Clickme.phs"{
				;logmes "調べたファイル名"+ffname+"/Clickme.phs"
				exist ffname+"/Clickme.phs" : c=strsize
			}
			
			if c=-1 : mkdir ffname : fname=ffname : bsave ""+fname+"/Clickme.phs",b//フォルダがなかったら作る
			if c!-1{//フォルダがあったら
				if stat=7 : return//「いいえ」→もどる
				repeat//「はい」→フォルダ名を検索
					if strmid(ffname,cnt,11)="Clickme.phs" : fname=strmid(ffname,0,cnt-1) : break
				loop
				bsave ""+fname+"/Clickme.phs",b
			}
		}
	}
	if msave_mode=1//上書き保存
	if msave_mode=2{//temp保存
		fffname=fname
		fname="temp"
		exist fname+"/Clickme.phs" : a=strsize; : logmes "tempのファイルサイズ="+a
		;logmes "fname="+fname+"を保存"
		if a=-1 : mkdir fname : bsave ""+fname+"/Clickme.phs",b//フォルダがなかったら作る
	}
		
		;logmes fname+"/stage.txtを保存"
		notesave fname+"/stage.txt"
		;その他ブロック
		notesel omapdata
		repeat my : ycnt=cnt+mapvmv : mapd="" : repeat mx : xcnt=cnt+mapvmv
			c=omap(xcnt,ycnt)
			mapd+=c
		loop : noteadd mapd,-1,0 :  loop : notesave fname+"/ostage.txt"
		
		;敵
		notesel emapdata//敵の情報をテキスト化
		enemy_vol=0
		repeat my : ycnt=cnt+mapvmv : repeat mx
				mapd=""
				mapx=cnt+mapvmv : mapy=ycnt+mapvmv
				c=emap(mapx,mapy)
				if c!"0"{
					repeat//カッコの中の数を代入する
						ccnt=cnt
						a=strmid(c,2+ccnt,1)//a:一時的
						if a=")" : break
					loop
					b=int(strmid(c,2,ccnt))//b:一時的に()の中の数字を代入
					if b=0 | b=1 | b=2 | b=3{
						mapd=""+b+","+edmap(mapx,mapy)+","+(mapx-mapvmv)+","+(mapy-mapvmv)+",10,5"//向きが一方向のみの敵
					}/*if {
						maped="1,"+c+","+edmap(mapx,mapy)\2+","+mapx+","+mapy+",100,100"//向きが二種類の敵
					}if c={
						maped="1,"+c+","+edmap(mapx,mapy)\4+","+mapx+","+mapy+",100,100"//向きが四種類の敵
					}*/
					
					noteadd mapd,-1,0
					enemy_vol++
				}
			loop
		loop
		;logmes fname+"/estage.txt"
		notesave fname+"/estage.txt"
		
		;マップの情報
		notesel mapinfo : a=0
		noteadd str(mx),a : a++
		noteadd str(my),a : a++
		noteadd str(px),a : a++//first_px
		noteadd str(py),a : a++//first_py
		notesave fname+"/info.txt"

		if msave_mode=2 : fname=fffname//tempだったら元の名前に戻す
		if msave_mode!2 : map_change=0
		return
	/*if play_mode=0 : return//遊ぶモードだったら(tempへセーブ)
	if play_mode=1{//作るモードだったら
		;dialog "遊びますか",2//質問ウィンドウ
		if stat=6 : play_mode=0 : return//はい
		return//いいえ
	}*/
	

#deffunc pbh_info int player_block_hit_px1, int player_block_hit_py1, int player_block_hit_px2, int player_block_hit_py2//プレイヤーの当たり判定を四角形で登録する
	pbhpx1=player_block_hit_px1 : pbhpy1=player_block_hit_py1 : pbhpx2=player_block_hit_px2 : pbhpy2=player_block_hit_py2//左上x,y:右上x,y
	if pbhpx2<pbhpx1 : pbhpx2=player_block_hit_px1 : pbhpx1=player_block_hit_px2//小さいほうをpbhpx1に、大きいほうをpbhpx2に代入する
	if pbhpy2<pbhpy1 : pbhpy2=player_block_hit_py1 : pbhpy1=player_block_hit_py2//小さいほうをpbhpy1に、大きいほうをpbhpy2に代入する
	psizex=abs(pbhpx2-pbhpx1) : psizey=abs(pbhpy2-pbhpy1)//プレイヤーのサイズ
return

#deffunc pbh int pblock_hit_direction, int pbh_setline, int pbh_setline_r, int pbh_setline_g, int pbh_setline_b//pcheck:今いる位置から調べるマス数
	if pbh_setline=1 : color pbh_setline_r,pbh_setline_g,pbh_setline_b//線の色
	a=pblock_hit_direction : d=0
	if -pbhpx1<=px & px<=msx-pbhpx2{//x座標が画面から出てなければ当たり判定を確認する
		if a=0{//左
			repeat (psizey-2)/pbh_cless
				ycnt=cnt*pbh_cless
				mapx=(px+pbhpx1-1)/bsize+mapvmv : mapy=limit((py+ycnt+pbhpy1+1)/bsize+mapvmv,mapvmv,mymax+mapvmv) : b=0 : c=map(mapx,mapy)//mapyの+1は上と下の判定ラインと被らないように
				if pbh_setline=1 : pset (px+pbhpx1-1)+wx_move,(py+ycnt+pbhpy1+1)+wy_move//確認用に当たり判定の線を引く
				repeat pbhl_str_vol//当たり判定のあるブロック数分調べる
					if c=pbhl_str(cnt) : b=1 : break
				loop
				if b=1 : d++//もし何かぶつかるブロックがあったらcにその数を代入する
				gosub*pbh_kyotu
			loop
		}
		if a=1{//上
			repeat psizex/pbh_cless
				xcnt=cnt*pbh_cless
				mapx=(px+xcnt+pbhpx1)/bsize+mapvmv : mapy=limit((py+pbhpy1)/bsize+mapvmv,mapvmv,mymax+mapvmv) : b=0 : c=map(mapx,mapy)
				if pbh_setline=1 : pset (px+xcnt+pbhpx1)+wx_move,(py+pbhpy1)+wy_move//確認用に当たり判定の線を引く
				repeat pbhu_str_vol//当たり判定のあるブロック数分調べる
					if c=pbhu_str(cnt) : b=1 : break// : logmes "引っかかった！"
				loop
				if b=1{
					d++//もし何かぶつかるブロックがあったらcにその数を代入する
					if c="b(19)" | c="b(20)" | c="b(21)" | c="b(22)"{
						dmmplay sesound(28)
						if c="b(20)" : kodama_vol++ : dmmplay sesound(5)
						if c="b(21)" : player_hp+5 : dmmplay sesound(27)
						map(mapx,mapy)="b(22)"
					}
					if c="b(23)" : dmmplay sesound(29) : map(mapx,mapy)="0" : mkphit_damage 1
				}
						
				gosub*pbh_kyotu
			loop
		}
		if a=2{//右
			repeat (psizey-2)/pbh_cless
				ycnt=cnt*pbh_cless
				mapx=(px+pbhpx2+1)/bsize+mapvmv : mapy=limit((py+ycnt+pbhpy1+1)/bsize+mapvmv,mapvmv,mymax+mapvmv) : b=0 : c=map(mapx,mapy)//mapyの+1は上と下の判定ラインと被らないように
				if pbh_setline=1 : pset (px+pbhpx2+1)+wx_move,(py+ycnt+pbhpy1+1)+wy_move//確認用に当たり判定の線を引く
				repeat pbhr_str_vol//当たり判定のあるブロック数分調べる
					if c=pbhr_str(cnt) : b=1 : break
				loop
				if b=1 : d++//もし何かぶつかるブロックがあったらcにその数を代入する
				gosub*pbh_kyotu
			loop
		}
		if a=3{//下
			repeat psizex/pbh_cless
				xcnt=cnt*pbh_cless
				mapx=(px+xcnt+pbhpx1)/bsize+mapvmv : mapy=limit((py+pbhpy2)/bsize+mapvmv,mapvmv,mymax+mapvmv) : b=0 : c=map(mapx,mapy)
				;if lclick=1 : logmes "mapy="+mapy+"c="+c
				if pbh_setline=1 : pset (px+xcnt+pbhpx1)+wx_move,(py+pbhpy2)+wy_move//確認用に当たり判定の線を引く
				repeat pbhd_str_vol//当たり判定のあるブロック数分調べる
					if c=pbhd_str(cnt) : b=1 : break// : logmes "引っかかった！"
				loop
				if b=1{
					d++//もし何かぶつかるブロックがあったらcにその数を代入する
					if c="b(12)" : pxmovep=8
					if c!"b(12)" : pxmovep=2
				}
				gosub*pbh_kyotu
			loop
		}
		if a=4{//真ん中
			mapx=(px+pbhpx1+psizex/2)/bsize+mapvmv : mapy=limit((py+pbhpy1+psizey/2)/bsize+mapvmv,mapvmv,mymax+mapvmv) : b=0
			if pbh_setline=1 : pset (px+pbhpx1+psizex/2)+wx_move,(py+pbhpy1+psizey/2)+wy_move//確認用に当たり判定の線を引く
			c=omap(mapx,mapy)
			if c="0"{//何もなかったら
				if pg!0{//下(通常)//player_rotation
					if pg=2 : px-bsize*2 : py-bsize*2 : pymove=-pymove
					pg=0 : spacep=1
				}
				if pswim=1 : pswim=0 : pymovep=1 : pxmovep=1 : dmmplay sesound(17)
			}
			if pg!2 & c="c(0)"{//上向きの重力
				if pg=0 | pg=4 : px+bsize*2 : py+bsize*2 : pymove=-pymove
				pg=2 : spacep=1
			}
			if pg!4 & c="c(1)"{//下向き
				if pg=2 : px-bsize*2 : py-bsize*2 : pymove=-pymove
				pg=4 : spacep=1
			}
			if pswim=0 & c="c(2)"{
				pswim=1 : pymovep=3 : pxmovep=3//泳ぐモード
				if pymove>pymovem/4 : pymove=pymovem/4 : spacep=1//上から水に入るとき、制限する
				if pymove<-pymovem/4 : pymove=-pymovem/4//下から水に入るとき、制限する
				dmmplay sesound(17)
			}
			//if pg!3 & c="c(2)" : pg=3 : protate=deg2rad(270)//右向き
			//if pg!1 & c="c(3)" : pg=1 : protate=deg2rad(90)//左向き
		}
	}
	return d
*pbh_kyotu
	if c="b(3)" : map(mapx,mapy)="b(4)" : vs_nest=1 : pgoal=1//灯篭
	if c="b(5)" : map(mapx,mapy)="0" : dmmplay sesound(5) : kodama_vol++//小魂
	if c="b(13)" : mkphit_damage 5
	if c="b(14)" : mkphit_damage player_hp//ダメージ音
return

#defcfunc loopan int count,int startp, int endp//loop_animation_num
	countt=count : p1=startp : p2=endp//countt!!
	if p1>p2 : p1=endp : p2=startp//小さいほうをp1,大きいほうをp2に代入する
	if countt<p1 | p2<=countt : countt=p1//範囲外の数だったら値をp1にする
	countt++//増加させる
	if countt=panip(3)+1 | countt=panip(5)+1 : if pswim=0 : dmmplay sesound(8)//足音鳴らす
	if countt=p2 : countt=p1//もしp2になったらp1にする
	//logmes "countt"+countt
return countt

#deffunc anything_fill str name//塗りつぶし
	if sb_mode=0{ 
		fsb=map(mapx,mapy)//fill_select_block//選択したブロック
		map(mapx,mapy)=name//最初のブロックを埋めたいブロック(name)にする
		checkx(0)=mapx : checky(0)=mapy : cv=0 : ccv=1//check_vol
		repeat
			//title "cnt"+cnt
			repeat ccv
			//logmes "cnt="+cnt+" checkx="+checkx(cnt)+" checky="+checky(cnt)
			if mapvmv<=checkx(cnt)-1 : if map(checkx(cnt)-1,checky(cnt))=fsb : map(checkx(cnt)-1,checky(cnt))=name : checkx2(cv)=checkx(cnt)-1 : checky2(cv)=checky(cnt) : cv++//左
			if mapvmv<=checky(cnt)-1 : if map(checkx(cnt),checky(cnt)-1)=fsb : map(checkx(cnt),checky(cnt)-1)=name : checkx2(cv)=checkx(cnt) : checky2(cv)=checky(cnt)-1 : cv++//上
			if checkx(cnt)+1<mx+mapvmv : if map(checkx(cnt)+1,checky(cnt))=fsb : map(checkx(cnt)+1,checky(cnt))=name : checkx2(cv)=checkx(cnt)+1 : checky2(cv)=checky(cnt) : cv++//右
			if checky(cnt)+1<my+mapvmv : if map(checkx(cnt),checky(cnt)+1)=fsb : map(checkx(cnt),checky(cnt)+1)=name : checkx2(cv)=checkx(cnt) : checky2(cv)=checky(cnt)+1 : cv++//下
			loop
			repeat cv : checkx(cnt)=checkx2(cnt) : checky(cnt)=checky2(cnt) : loop
			//logmes "checkvol="+cv
			if cv=0 : break
			ccv=cv//repeat用
			cv=0
		loop
	}
	if sb_mode=1{ 
		fsb=omap(mapx,mapy)//fill_select_block//選択したブロック
		omap(mapx,mapy)=name//最初のブロックを埋めたいブロック(name)にする
		checkx(0)=mapx : checky(0)=mapy : cv=0 : ccv=1//check_vol
		repeat
			//title "cnt"+cnt
			repeat ccv
			//logmes "cnt="+cnt+" checkx="+checkx(cnt)+" checky="+checky(cnt)
			if mapvmv<=checkx(cnt)-1 : if omap(checkx(cnt)-1,checky(cnt))=fsb : omap(checkx(cnt)-1,checky(cnt))=name : checkx2(cv)=checkx(cnt)-1 : checky2(cv)=checky(cnt) : cv++//左
			if mapvmv<=checky(cnt)-1 : if omap(checkx(cnt),checky(cnt)-1)=fsb : omap(checkx(cnt),checky(cnt)-1)=name : checkx2(cv)=checkx(cnt) : checky2(cv)=checky(cnt)-1 : cv++//上
			if checkx(cnt)+1<mx+mapvmv : if omap(checkx(cnt)+1,checky(cnt))=fsb : omap(checkx(cnt)+1,checky(cnt))=name : checkx2(cv)=checkx(cnt)+1 : checky2(cv)=checky(cnt) : cv++//右
			if checky(cnt)+1<my+mapvmv : if omap(checkx(cnt),checky(cnt)+1)=fsb : omap(checkx(cnt),checky(cnt)+1)=name : checkx2(cv)=checkx(cnt) : checky2(cv)=checky(cnt)+1 : cv++//下
			loop
			repeat cv : checkx(cnt)=checkx2(cnt) : checky(cnt)=checky2(cnt) : loop
			//logmes "checkvol="+cv
			if cv=0 : break
			ccv=cv//repeat用
			cv=0
		loop
	}
	if sb_mode=2{ 
		fsb=emap(mapx,mapy)//fill_select_block//選択したブロック
		emap(mapx,mapy)=name//最初のブロックを埋めたいブロック(name)にする
		checkx(0)=mapx : checky(0)=mapy : cv=0 : ccv=1//check_vol
		repeat
			//title "cnt"+cnt
			repeat ccv
			//logmes "cnt="+cnt+" checkx="+checkx(cnt)+" checky="+checky(cnt)
			if mapvmv<=checkx(cnt)-1 : if emap(checkx(cnt)-1,checky(cnt))=fsb : emap(checkx(cnt)-1,checky(cnt))=name : checkx2(cv)=checkx(cnt)-1 : checky2(cv)=checky(cnt) : cv++//左
			if mapvmv<=checky(cnt)-1 : if emap(checkx(cnt),checky(cnt)-1)=fsb : emap(checkx(cnt),checky(cnt)-1)=name : checkx2(cv)=checkx(cnt) : checky2(cv)=checky(cnt)-1 : cv++//上
			if checkx(cnt)+1<mx+mapvmv : if emap(checkx(cnt)+1,checky(cnt))=fsb : emap(checkx(cnt)+1,checky(cnt))=name : checkx2(cv)=checkx(cnt)+1 : checky2(cv)=checky(cnt) : cv++//右
			if checky(cnt)+1<my+mapvmv : if emap(checkx(cnt),checky(cnt)+1)=fsb : emap(checkx(cnt),checky(cnt)+1)=name : checkx2(cv)=checkx(cnt) : checky2(cv)=checky(cnt)+1 : cv++//下
			loop
			repeat cv : checkx(cnt)=checkx2(cnt) : checky(cnt)=checky2(cnt) : loop
			//logmes "checkvol="+cv
			if cv=0 : break
			ccv=cv//repeat用
			cv=0
		loop
	}
return

#deffunc rsgate
	gate_vol=0
return

#deffunc mkgate str file_pass, int gate_pos_x, int gate_pos_y//make_gate
	gate_file(gate_vol)=file_pass : gatex(gate_vol)=gate_pos_x : gatey(gate_vol)=gate_pos_y : gsicnt(gate_vol)=0 : gate_vol++
return

//draw_gate
#deffunc drgate
	repeat gate_vol
		gmode 2 : pos gatex(cnt)+wx_move,gatey(cnt)+wy_move : celput effepic(1),acnt\120
		//boxline gatex(cnt)-32+wx_move,gatey(cnt)-32+wy_move,gatex(cnt)+32+wx_move,gatey(cnt)+32+wy_move
		//color 255,255,255 : boxline pbhpx1,py,pbhpx2,py+32
		
		if px+pbhpx1>=gatex(cnt)-32 & px+pbhpx2<=gatex(cnt)+32 & py+pbhpy1<=gatey(cnt)+32 & py+pbhpy2>=gatey(cnt)-32 & mmani=0{
			gsicnt(cnt)++//gate_stage_info_count
			color 243,0,255 : gmode 4,,,255 : pos gatex(cnt)-160+wx_move,gatey(cnt)-150+wy_move : celput effepic(2),limit(gsicnt(cnt)/20,0,2)
			gmode 4,,,gsicnt(cnt) : pos px,py : celput mainpic(12)
			if limit(gsicnt(cnt)/20,0,2)=2 : pos gatex(cnt)-160+wx_move+50,gatey(cnt)+wy_move-120 : font "",18 : color 0,0,0 : mes gate_file(cnt)
			if ue=1 : vs_nest=1 : stage_map_name=gate_file(cnt) : map_move=1 : dmmstop -1 : dmmplay sesound(10) : gsicnt(cnt)=0
		}else : if gsicnt(cnt)!0 : gsicnt(cnt)=0
	loop
return

#deffunc black_inout int count ,int mode
	if mode=0 : gmode 3,,,count*4 : pos 0,0 : celput effepic(3)//in
	if mode=1 : gmode 3,,,255-count*4 : pos 0,0 : celput effepic(3)//out
	if mode=2 : repeat 64 : redraw 1 : redraw 0 : gmode 3,,,cnt*4 : pos 0,0 : celput effepic(3) : await 16 : loop
return

#deffunc mkenemy var enemy_select_number,var enemy_direction, var enemy_pos_x, var enemy_pos_y, var enemy_can_movex, var enemy_can_movey//make_enemy
	;別の変数で登録
	enemysnum(enemy_vol)=enemy_select_number : enemydir(enemy_vol)=enemy_direction
	fenemypx(enemy_vol)=double(enemy_pos_x)*bsize : fenemypy(enemy_vol)=double(enemy_pos_y)*bsize
	enemypx(enemy_vol)=fenemypx(enemy_vol) : enemypy(enemy_vol)=fenemypy(enemy_vol)
	enemycmx(enemy_vol)=enemy_can_movex : enemycmy(enemy_vol)=enemy_can_movey

	exmove(enemy_vol)=0.0//左右
	eymove(enemy_vol)=0//落下
	enemyl(enemy_vol)=1//命
	enemy_mode(enemy_vol)=0//状態
	enemy_anipc(enemy_vol)=rnd(63)//アニメーション用
	enemy_check(enemy_vol)=0//敵用の管理変数
	enemy_cnt(enemy_vol)=0//敵用のcnt
	edcnt(enemy_vol)=0//死亡後のcnt
	edcheck(enemy_vol)=0//方向転換の管理変数
	;logmes ""+enemy_vol+"体目の情報"+" enemysnum="+enemysnum(enemy_vol)+" enemydir"+enemydir(enemy_vol)+" enemypx="+enemypx(enemy_vol)+" enemypy="+enemypy(enemy_vol)+" enemycmx="+enemycmx(enemy_vol)+" enemycmy="+enemycmy(enemy_vol)+" enemyl="+enemyl(enemy_vol)
	enemy_vol++//個体数を増やす
return

#deffunc epos int epx1, int epy1//写真を貼る位置
	enemy_pos_x1=epx1 : enemy_pos_y1=epy1
	//color 0,255,0 : boxline enemypx(cnt)-enemy_pos_x1,enemypy(cnt)-enemy_pos_y1,enemypx(cnt)-enemy_pos_x2,enemypy(cnt)-enemy_pos_y2
	pos enemypx(cnt)-enemy_pos_x1+wx_move,enemypy(cnt)-enemy_pos_y1+wy_move
return

#deffunc enemy_info int enemy_block_hit_px1, int enemy_block_hit_py1, int enemy_block_hit_px2, int enemy_block_hit_py2
	ebhpx1=enemy_block_hit_px1 : ebhpy1=enemy_block_hit_py1 : ebhpx2=enemy_block_hit_px2 : ebhpy2=enemy_block_hit_py2//左上x,y:右上x,y
	if ebhpx2<ebhpx1 : ebhpx2=enemy_block_hit_px1 : ebhpx1=enemy_block_hit_px2//小さいほうをpbhpx1に、大きいほうをpbhpx2に代入する
	if ebhpy2<ebhpy1 : ebhpy2=enemy_block_hit_py1 : ebhpy1=enemy_block_hit_py2//小さいほうをpbhpy1に、大きいほうをpbhpy2に代入する
	esizex=abs(ebhpx2-ebhpx1) : esizey=abs(ebhpy2-ebhpy1)//プレイヤーのサイズ
return
	
#deffunc ehitcheck int edamage, int drawbox, int enemy_can_push//敵の当たり判定
	;logmes ""+edamage
	if enemyl(ecnt)>0 & drawbox=1 : color 255,0,0 : boxline enemypx(ecnt)+ebhpx1-enemy_pos_x1+wx_move,enemypy(ecnt)+ebhpy1-enemy_pos_y1+wy_move,enemypx(ecnt)+ebhpx2-enemy_pos_x1+wx_move,enemypy(ecnt)+ebhpy2-enemy_pos_y1+wy_move
	if enemypy(ecnt)>msy+bsize : enemyl(ecnt)=-1//落ちたら死亡
	/*if px+pbhpx1<enemypx(cnt)+ebhpx2-enemy_pos_x1 & px+pbhpx2>enemypx(cnt)+ebhpx1-enemy_pos_x1 & py+pbhpy1+psizey/2<enemypy(cnt)+ebhpy1-enemy_pos_y1 & enemypy(cnt)+ebhpy1-enemy_pos_y1<=py+pbhpy2{//踏む判定に入ったら
		;logmes "当たり判定するぜお"
		if enemy_can_push=1 & enemy_hit_check=0{//踏むことで倒せるなら
			if pymove>0 & enemyl(cnt)>0 : enemyl(cnt)-1 : pymove=-pymovem-2
		}
	}*/
	if px+pbhpx1<enemypx(cnt)+ebhpx2-enemy_pos_x1 & px+pbhpx2>enemypx(cnt)+ebhpx1-enemy_pos_x1 & py+pbhpy1<enemypy(cnt)+ebhpy2-enemy_pos_y1 & py+pbhpy2>enemypy(cnt)+ebhpy1-enemy_pos_y1{//敵に当たってたら〜
		if enemy_can_push=1{//踏むことで倒せるなら
			if pymove>0 & enemyl(cnt)>0{//踏んだ時
				enemyl(cnt)-1//踏んだ奴のlifeを減らす
				canjump=1//ジャンプ可能かどうかの確認
			}
		}
		if enemyl(cnt)>0{
			/*bb=enemysnum(cnt)
			if bb=0 | bb=1 | bb=2 | bb=3{//向く方向が右か左しかない敵だったら〜
				if enemydir(cnt)=0 : enemydir(cnt)=1
				if enemydir(cnt)=1 : enemydir(cnt)=0
			}*/
			mkphit_damage edamage
		}
	}
return

#deffunc mkphit_damage int damage_vol
	if player_damage_mode=0 & pdeath=0{
		damage_effect_cnt(damage_effect_vol)=0 : damage_effect_posx(damage_effect_vol)=px+pbhpx1+rnd(psizex)+wx_move : damage_effect_posy(damage_effect_vol)=py+pbhpy1+rnd(psizey)+wy_move : phit_damage(damage_effect_vol)=damage_vol
		player_hp-damage_vol : player_damage_mode=1
		dmmplay sesound(13)//ダメージ音
		damage_effect_vol++
	}
return

;ダメージ表示
#deffunc drphit_damage
	a=0//確認用
	repeat damage_effect_vol
		color 243,0,255 : gmode 4,,,255-damage_effect_cnt(cnt) : pos damage_effect_posx(cnt),damage_effect_posy(cnt) : celput effepic(5)
		if damage_effect_cnt(cnt)<255 : color 0,0,0 : pos damage_effect_posx(cnt)-8,damage_effect_posy(cnt)-8 : mes phit_damage(cnt) : damage_effect_cnt(cnt)++
		if damage_effect_cnt(cnt)=255 : a++
	loop
	if a=damage_effect_vol : damage_effect_vol=0
return

#deffunc ebh int eblock_hit_direction, int ebh_setline, int ebh_setline_r, int ebh_setline_g, int ebh_setline_b//echeck:今いる位置から調べるマス数
	if ebh_setline=1 : color ebh_setline_r,ebh_setline_g,ebh_setline_b//線の色
	aa=eblock_hit_direction : d=0
	if -bsize<=enemypx(ecnt)-enemy_pos_x1+ebhpx1 & enemypx(ecnt)-enemy_pos_x1+ebhpx2<=msx+bsize{//x座標が画面から出てなければ当たり判定を確認する
		if aa=0{//左
			repeat (esizey-2)/pbh_cless
				ycnt=cnt*pbh_cless
				;logmes (enemypx(ecnt)-enemy_pos_x1+ebhpx1-1)
				mapx=int(enemypx(ecnt)-enemy_pos_x1+ebhpx1-1)/bsize+mapvmv : mapy=limit((enemypy(ecnt)-enemy_pos_y1+ebhpy1+ycnt+1)/bsize+mapvmv,mapvmv,mymax+mapvmv) : b=0 : c=map(mapx,mapy)//mapyの+1は上と下の判定ラインと被らないように
				if ebh_setline=1 : pset enemypx(ecnt)-enemy_pos_x1+ebhpx1-1+wx_move,(enemypy(ecnt)-enemy_pos_y1+ebhpy1+ycnt+1)+wy_move//確認用に当たり判定の線を引く
				repeat pbhl_str_vol//当たり判定のあるブロック数分調べる
					if c=pbhl_str(cnt) : b=1 : break
				loop
				getkey lclick,1
				if int(enemypx(ecnt)-enemy_pos_x1+ebhpx1-1)<0 : b=1
				if b=1 : d++//もし何かぶつかるブロックがあったらcにその数を代入する
				;gosub*pbh_kyotu
			loop
		}
		if aa=1{//上
			repeat esizex/pbh_cless
				xcnt=cnt*pbh_cless
				mapx=int(enemypx(ecnt)-enemy_pos_x1+ebhpx1+xcnt)/bsize+mapvmv : mapy=limit((enemypy(ecnt)-enemy_pos_y1+ebhpy1)/bsize+mapvmv,mapvmv,mymax+mapvmv) : b=0 : c=map(mapx,mapy)
				if ebh_setline=1 : pset (enemypx(ecnt)-enemy_pos_x1+ebhpx1+xcnt)+wx_move,(enemypy(ecnt)-enemy_pos_y1+ebhpy1)+wy_move//確認用に当たり判定の線を引く
				repeat pbhu_str_vol//当たり判定のあるブロック数分調べる
					if c=pbhu_str(cnt) : b=1 : break// : logmes "引っかかった！"
				loop
				if b=1 : d++//もし何かぶつかるブロックがあったらcにその数を代入する
				;gosub*pbh_kyotu
			loop
		}
		if aa=2{//右
			repeat (esizey-2)/pbh_cless
				ycnt=cnt*pbh_cless
				mapx=int(enemypx(ecnt)-enemy_pos_x1+ebhpx2+1)/bsize+mapvmv : mapy=limit((enemypy(ecnt)-enemy_pos_y1+ebhpy1+ycnt+1)/bsize+mapvmv,mapvmv,mymax+mapvmv) : b=0 : c=map(mapx,mapy)//mapyの+1は上と下の判定ラインと被らないように
				if ebh_setline=1 : pset (enemypx(ecnt)-enemy_pos_x1+ebhpx2+1)+wx_move,(enemypy(ecnt)-enemy_pos_y1+ebhpy1+ycnt+1)+wy_move//確認用に当たり判定の線を引く
				repeat pbhr_str_vol//当たり判定のあるブロック数分調べる
					if c=pbhr_str(cnt) : b=1 : break
				loop
				if msx<int(enemypx(ecnt)-enemy_pos_x1+ebhpx2+1) : b=1
				if b=1 : d++//もし何かぶつかるブロックがあったらcにその数を代入する
				;gosub*pbh_kyotu
			loop
		}
		if aa=3{//下
			repeat esizex/pbh_cless
				xcnt=cnt*pbh_cless
				mapx=int(enemypx(ecnt)-enemy_pos_x1+ebhpx1+xcnt)/bsize+mapvmv : mapy=limit((enemypy(ecnt)-enemy_pos_y1+ebhpy2)/bsize+mapvmv,mapvmv,mymax+mapvmv) : b=0 : c=map(mapx,mapy)
				;if lclick=1 : logmes "mapy="+mapy+"c="+c
				if ebh_setline=1 : pset (enemypx(ecnt)-enemy_pos_x1+ebhpx1+xcnt)+wx_move,(enemypy(ecnt)-enemy_pos_y1+ebhpy2)+wy_move//確認用に当たり判定の線を引く
				repeat pbhd_str_vol//当たり判定のあるブロック数分調べる
					if c=pbhd_str(cnt) : b=1 : break// : logmes "引っかかった！"
				loop
				if b=1 : d++//もし何かぶつかるブロックがあったらcにその数を代入する
				;gosub*pbh_kyotu
			loop
		}
		/*if a=4{//真ん中
			mapx=(px+pbhpx1+psizex/2)/bsize+mapvmv : mapy=limit((py+pbhpy1+psizey/2)/bsize+mapvmv,mapvmv,mymax+mapvmv) : b=0
			if pbh_setline=1 : pset (px+pbhpx1+psizex/2)+wx_move,(py+pbhpy1+psizey/2)+wy_move//確認用に当たり判定の線を引く
			c=omap(mapx,mapy)
			if pg!0 & c="0"{//下(通常)//player_rotation
				if pg=2 : px-psizex*2+5 : py-bsize*2+5 : pymove=-pymove
				if pg=4 : pymovem-pymovem_plus
				pg=0 : spacep=1
			}
			if pg!2 & c="c(0)"{//上向きの重力
				if pg=0 | pg=4 : px+psizex*2 : py+bsize*2 : pymove=-pymove
				if pg=4 : pymovem-pymovem_plus
				pg=2 : spacep=1
			}
			if pg!4 & c="c(1)"{//下向き
				if pg=2 : pymove=-pymove
				pg=4 : protate=0 : pymovem+pymovem_plus
			}
			//if pg!3 & c="c(2)" : pg=3 : protate=deg2rad(270)//右向き
			//if pg!1 & c="c(3)" : pg=1 : protate=deg2rad(90)//左向き
		}*/
	}
	return d

//各ステージの進行状況を保存
#deffunc play_data_load
	exist "playerdata.dat" : a=strsize : count=0
	if a!-1{
		bload "playerdata.dat",first_story,,count*play_data_save_pace : count++
		bload "playerdata.dat",akodama_vol,,count*play_data_save_pace : count++
		bload "playerdata.dat",stage_map,,count*play_data_save_pace : count++
	}
return
#deffunc play_data_save
	exist "playerdata.dat" : a=strsize : count=0
	if a=-1 : bsave "playerdata.dat",a//なかったら
	bsave "playerdata.dat",first_story,,count*play_data_save_pace : count++
	bsave "playerdata.dat",akodama_vol,,count*play_data_save_pace : count++
	bsave "playerdata.dat",stage_map,,count*play_data_save_pace : count++
return

#deffunc story int number
	num=number
	;sdim type_speaker,20,20 : sdim type_str,100,100
	if num=0{
		a=0
		countm=200;200//次の話へ進むまでの待ち時間//デバック
		dmmplay bgmsound(3)
		type_speaker="自分","自分","自分"
		type_str(0)={"あー昨日からずっとパソコンしてたなぁ...
					てかここ数年まともに外出してねぇなぁ"}
		type_str(1)={"(46になってもこんな調子だと、そろそろ人生終わってるやつだと思うなぁ)"}
		type_str(2)={"このままじゃいかん...
					よし！こんな自分とおさらばするためにまずは外に出よう！"}
		type_str_vol=length(type_str)
		dmmplay sesound(21)//タイピング音
		repeat
			redraw 1 : redraw 0
			gosub *keycontrol
			gmode 0 : pos 0,0 : celput storypic(1)//背景
			color 243,0,255 : gmode 4,,,255
			pos 0,0 : celput storypic(2)//テロップ
			color 0,0,0 : font "",32
			pos 64,462 : mes ""+type_speaker(a)//話し手の名前を表示
			font "",30
			pos 32,520 : mes type_str(a)//内容を描画
			count++
			if count>countm{//指定時間過ぎたら
				ga=ginfo_act
				color 243,0,255 : gmode 4,,,255 : pos 940+cos(deg2rad(count-countm)*4)*10,560 : celput storypic(4)
				if (enter=1 | lclick=1) & ga!-1 : a++ : count=0 : if a=type_str_vol : break
			}
			await 16
			if cnt<128 : black_inout cnt/2,1
		loop
		black_inout 0,2//黒くする
		dmmstop bgmsound(3)
		dmmplay sesound(19) : wait 550//歩いて玄関へ
		dmmplay sesound(18) : wait 200//ドアを開ける
	}if num=1{
		mode=0 : px=200//デバック480
		py=450 : panicp=12
		panipc=2,2,2,0
		a=0 : repeat length(panipc) : panip(cnt)=a : a=a+panipc(cnt) : loop
		setease py-128,py,ease_bounce_out
		dmmplay bgmsound(6)//小鳥の声
		repeat
			acnt=cnt
			redraw 1 : redraw 0
				gosub*keycontrol
				gmode 0
				pos 0,0 : celput storypic(5)//背景
				color 243,0,255 : gmode 4,,,255//プレイヤーを描画
				pos px+wx_move,py+wy_move : celput storypic(6),pani,2,2
				panic++ : //player_animation_check//player_animation_per//一個のアニメーションを変えるまでのフレーム数
				if px>500 & mode=0{
					 mode=1 : ccnt=0 : dmmplay sesound(22)//車と衝突
					if px_direction=0 : pani=0 : else : pani=2
				}
				if mode=1{//車が来る
					ccnt++
					pos 2000-ccnt*10,0 : celput storypic(7)
					if ccnt=200 : mode=2 : dmmplay sesound(26) : dmmplay sesound(24)
				}
				if mode=2{//ぶつかった後
					action_cnt++
					px-2
					py=getease(action_cnt,140)
					if py>=440 & bc=0 : bc=1 : dmmplay sesound(23)//bechi_check
					if py<440 & bc=1 : bc=0
					if action_cnt<50 : pani=4
					if action_cnt>=50 : pani=5
					pos 2000-ccnt*10+action_cnt,0 : celput storypic(7)//車
					if action_cnt>200 : black_inout 0,2 : break
				}
				;左右
			;pxymovep_cnt++//加速、減速のしやすさ用
			if mode=0{
				if hidari=1 & acnt\pxmovep=0 & 0<px : px-2 : hidarip=1 : ccnt++ : pani=(ccnt/panicp)\2 : if migip=0 : px_direction=0//pxmove--
				if hidari=0 : hidarip=0
				if migi=1 & acnt\pxmovep=0 & px+bsize<ginfo_winx : px+2 : migip=1 : ccnt++ : pani=2+(ccnt/panicp)\2 : if hidarip=0 : px_direction=1//pxmove++
				if migi=0 : migip=0
				if (hidari=0 & migi=0) | (hidari=1 & migi=1){
					if px_direction=0{
						if panic\panipf(0)=0 : pani=0
					}if px_direction=1{
						if panic\panipf(0)=0 : pani=2
					}
					ccnt=0
				}
			}
			await 16
			if cnt<64 : black_inout cnt,1
		loop
		dmmstop bgmsound(6)
	}if num=2{
		wait 500
		countm=200;200//次の話へ進むまでの待ち時間//デバック
		type_speaker="???","自分","???","自分","リリー","自分","リリー","リリー","リリー","リリー","自分","リリー","自分","リリー","リリー","リリー","リリー","リリー","自分","リリー","リリー","リリー","リリー","リリー","リリー","リリー","リリー","自分","リリー","自分","リリー","自分"
		type_str(0)={"えーと　起きましたか〜？"}
		type_str(1)={"ここは...どこだ"}
		type_str(2)={"ここは、天国と地獄の中間世界です"}
		type_str(3)={".....あんたは？"}
		type_str(4)={"あ！　申し遅れました。私は天使の「リリー」というものです"}
		type_str(5)={"ほぉ〜...で、リリー...さん？
					なんで俺は　こ　ん　な　と　こ　ろ　にいるんだ"}
		type_str(6)={"あなたはここ 二十年、自堕落な生活を送っていたため
					死んだ場合地獄に送られる予定でした"}
		type_str(7)={"ですが、今までの生活を反省し行動をしたので
					「これは地獄送りを考え直す必要があるな。」と思っていたとき"}
		type_str(8)={"あなたが車に派手に飛ばされて亡くなったので
					それを考え直す時間がありませんでした。"}
		type_str(9)={"このままだと天国送りか地獄送りかの決断がはっきりできないと思ったので
					あなたに生き返ってもらうことにしました。"}
		type_str(10)={"はい？"}
		type_str(11)={"ですが何もなしでは生き返ることはできませんよ？
					こちらの与える仕事をやってもらいます！"}
		type_str(12)={"いやいやいや、そういうことじゃなくてね？
					なんで生き返らせる必要があるの？"}
		type_str(13)={"判断材料として何かをやらせることはわかるけど
					だけど生き返らせてまでやることか？
					今までの行動だけでいいんじゃないのか？"}
		type_str(14)={"それがそうとはいかないんですよ。"}
		type_str(15)={"死者の魂は担当天使がきっちり天国が地獄に送る必要があるのですが、
					ルールとして「生きているときの行動」で
					どっちに送るかを決断しなければいけません"}
		type_str(16)={"そしてあなたのようにどっちかを判断しずらいケースの場合
					こちらの雑務...(ｺﾎﾝ
					　　　　仕事を行ってもらい"}
		type_str(17)={"いったん生き返らせた後の行動でまた決断を行うことになっています。"}
		type_str(18)={"今、雑務って..."}
		type_str(19)={"な　なので仕事を与えたいのですが、やります？"}
		type_str(20)={"で　ですがやってもらわないと何もないこの世界で
					永遠に過ごすことになりますよ（汗
					やりますよね？"}
		type_str(21)={"本当に言ってます？"}
		type_str(22)={"お願いです！仕事をやってください！
					そうしないと私が怒られちゃうんですよ(´;ω;｀)"}
		type_str(23)={"よかった！やってくれるんですね！"}
		type_str(24)={"では、あなたを仕事場へ転送します"}
		type_str(25)={"そこで最初のゲートに入ってください"}
		type_str(26)={"ゲートの奥には魂が残されている場所になっているので
					回収し、魂を「灯篭」に納めてください"}
		type_str(27)={"おいおい、回収ったって、俺デブだからクッソ時間かかるぞ？（ドヤ"}
		type_str(28)={"そこは大丈夫です
					あなたが動きやすいような体型にしておきましたから"}
		type_str(29)={"うお、ほんとだスリムボディーになってる！（歓喜"}
		type_str(30)={"では、頼みましたよ"}
		type_str(31)={"ああ、わぁーたよ"}
		type_str_vol=length(type_str) : a=0 : bb=0
		dmmplay bgmsound(4)//神秘的なやつ
		repeat
			redraw 1 : redraw 0
			gosub *keycontrol
			gmode 0 : pos 0,0 : celput storypic(8)//背景
			color 243,0,255 : gmode 4,,,255
			pos 250,-100
			if a<4 : celput storypic(9),,0.8,0.8//リリー（影）
			if a>=4 : celput storypic(3),,0.8,0.8//リリー
			color 243,0,255 : gmode 4,,,255 : pos 0,0 : celput storypic(2)//テロップ
			color 0,0,0 : font "",32
			pos 64,462 : mes ""+type_speaker(a)//話し手の名前を表示
			font "",30,
			pos 32,520 : mes type_str(a)//内容を描画
			count++
			if count>countm{//指定時間過ぎたら
				color 243,0,255 : gmode 4,,,255 : pos 940+cos(deg2rad(count-countm)*4)*10,560 : celput storypic(4)//矢印
				ga=ginfo_act
				if 19<=a & a<=22{
					gmode 4,,,100 : pos 100,200 : celput storypic(10)
					pos 600,200 : celput storypic(11)
					if hidari=1 : bb=0
					if migi=1 : bb=1
					if (100<moux & moux<420 & 200<mouy & mouy<440) & ga!-1 & check=0 : bb=0 : check=1 : if lclick=1 & lclickp=0 : if a!21 : a=23 : else : a=21 : a++ : count=0
					if (600<moux & moux<920 & 200<mouy & mouy<440) & ga!-1 & check=0 : bb=1 : check=1 : if lclick=1 & lclickp=0{
						count=0
						if a=21 : a=23
						if a!21 : a++ : if a=23 : a=20
						
					}
					if bb=0 : color 243,0,255 : gmode 4,,,255 : pos 100,200 : celput storypic(10)
					if bb=1 : color 243,0,255 : gmode 4,,,255 : pos 600,200 : celput storypic(11)
					if enter=1 & enterp=0 & ga!-1{
						if bb=0{//はい
							if a!21 : a=23
							if a=21 : a++
						}
						if bb=1{
							if a=21 : a=23
							if a!21 : a++ : if a=23 : a=20
						}
						count=0
					}check=0
				}else{
				if (enter=1 | lclick=1) & ga!-1 : a++ : count=0 : enterp=1 : lclickp=1 : if a=type_str_vol : break
				}if enter=0 : enterp=0
				if lclick=0 : lclickp=0
			}
			await 16
			if cnt<255 : black_inout cnt/4,1
		loop
		black_inout 0,2//黒くする
		dmmstop bgmsound(4)
		dmmplay sesound(25) : wait 200//ワープ
	}
return
*owaru
	dialog "終了しますか？",2 : owaruc=stat
	if owaruc=6 : chdir first_dir : play_data_save : end
	if owaruc=7 : return

*kyouseiowaru
	dialog "すみませんがエラーが発生したため、強制終了します",1
	chdir first_dir : play_data_save
	end